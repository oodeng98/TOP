{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * gridstack-engine.ts 10.3.1\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */\nimport { Utils } from './utils';\n/**\n * Defines the GridStack engine that does most no DOM grid manipulation.\n * See GridStack methods and vars for descriptions.\n *\n * NOTE: values should not be modified directly - call the main GridStack API instead\n */\nclass GridStackEngine {\n  constructor(opts = {}) {\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.column = opts.column || 12;\n    this.maxRow = opts.maxRow;\n    this._float = opts.float;\n    this.nodes = opts.nodes || [];\n    this.onChange = opts.onChange;\n  }\n  batchUpdate(flag = true, doPack = true) {\n    if (!!this.batchMode === flag) return this;\n    this.batchMode = flag;\n    if (flag) {\n      this._prevFloat = this._float;\n      this._float = true; // let things go anywhere for now... will restore and possibly reposition later\n      this.cleanNodes();\n      this.saveInitial(); // since begin update (which is called multiple times) won't do this\n    } else {\n      this._float = this._prevFloat;\n      delete this._prevFloat;\n      if (doPack) this._packNodes();\n      this._notify();\n    }\n    return this;\n  }\n  // use entire row for hitting area (will use bottom reverse sorted first) if we not actively moving DOWN and didn't already skip\n  _useEntireRowArea(node, nn) {\n    return (!this.float || this.batchMode && !this._prevFloat) && !this._hasLocked && (!node._moving || node._skipDown || nn.y <= node.y);\n  }\n  /** @internal fix collision on given 'node', going to given new location 'nn', with optional 'collide' node already found.\n   * return true if we moved. */\n  _fixCollisions(node, nn = node, collide, opt = {}) {\n    this.sortNodes(-1); // from last to first, so recursive collision move items in the right order\n    collide = collide || this.collide(node, nn); // REAL area collide for swap and skip if none...\n    if (!collide) return false;\n    // swap check: if we're actively moving in gravity mode, see if we collide with an object the same size\n    if (node._moving && !opt.nested && !this.float) {\n      if (this.swap(node, collide)) return true;\n    }\n    // during while() collisions MAKE SURE to check entire row so larger items don't leap frog small ones (push them all down starting last in grid)\n    let area = nn;\n    if (!this._loading && this._useEntireRowArea(node, nn)) {\n      area = {\n        x: 0,\n        w: this.column,\n        y: nn.y,\n        h: nn.h\n      };\n      collide = this.collide(node, area, opt.skip); // force new hit\n    }\n    let didMove = false;\n    let newOpt = {\n      nested: true,\n      pack: false\n    };\n    while (collide = collide || this.collide(node, area, opt.skip)) {\n      // could collide with more than 1 item... so repeat for each\n      let moved;\n      // if colliding with a locked item OR loading (move after) OR moving down with top gravity (and collide could move up) -> skip past the collide,\n      // but remember that skip down so we only do this once (and push others otherwise).\n      if (collide.locked || this._loading || node._moving && !node._skipDown && nn.y > node.y && !this.float && (\n      // can take space we had, or before where we're going\n      !this.collide(collide, {\n        ...collide,\n        y: node.y\n      }, node) || !this.collide(collide, {\n        ...collide,\n        y: nn.y - collide.h\n      }, node))) {\n        node._skipDown = node._skipDown || nn.y > node.y;\n        moved = this.moveNode(node, {\n          ...nn,\n          y: collide.y + collide.h,\n          ...newOpt\n        });\n        if ((collide.locked || this._loading) && moved) {\n          Utils.copyPos(nn, node); // moving after lock become our new desired location\n        } else if (!collide.locked && moved && opt.pack) {\n          // we moved after and will pack: do it now and keep the original drop location, but past the old collide to see what else we might push way\n          this._packNodes();\n          nn.y = collide.y + collide.h;\n          Utils.copyPos(node, nn);\n        }\n        didMove = didMove || moved;\n      } else {\n        // move collide down *after* where we will be, ignoring where we are now (don't collide with us)\n        moved = this.moveNode(collide, {\n          ...collide,\n          y: nn.y + nn.h,\n          skip: node,\n          ...newOpt\n        });\n      }\n      if (!moved) {\n        return didMove;\n      } // break inf loop if we couldn't move after all (ex: maxRow, fixed)\n      collide = undefined;\n    }\n    return didMove;\n  }\n  /** return the nodes that intercept the given node. Optionally a different area can be used, as well as a second node to skip */\n  collide(skip, area = skip, skip2) {\n    const skipId = skip._id;\n    const skip2Id = skip2?._id;\n    return this.nodes.find(n => n._id !== skipId && n._id !== skip2Id && Utils.isIntercepted(n, area));\n  }\n  collideAll(skip, area = skip, skip2) {\n    const skipId = skip._id;\n    const skip2Id = skip2?._id;\n    return this.nodes.filter(n => n._id !== skipId && n._id !== skip2Id && Utils.isIntercepted(n, area));\n  }\n  /** does a pixel coverage collision based on where we started, returning the node that has the most coverage that is >50% mid line */\n  directionCollideCoverage(node, o, collides) {\n    if (!o.rect || !node._rect) return;\n    let r0 = node._rect; // where started\n    let r = {\n      ...o.rect\n    }; // where we are\n    // update dragged rect to show where it's coming from (above or below, etc...)\n    if (r.y > r0.y) {\n      r.h += r.y - r0.y;\n      r.y = r0.y;\n    } else {\n      r.h += r0.y - r.y;\n    }\n    if (r.x > r0.x) {\n      r.w += r.x - r0.x;\n      r.x = r0.x;\n    } else {\n      r.w += r0.x - r.x;\n    }\n    let collide;\n    let overMax = 0.5; // need >50%\n    for (let n of collides) {\n      if (n.locked || !n._rect) {\n        break;\n      }\n      let r2 = n._rect; // overlapping target\n      let yOver = Number.MAX_VALUE,\n        xOver = Number.MAX_VALUE;\n      // depending on which side we started from, compute the overlap % of coverage\n      // (ex: from above/below we only compute the max horizontal line coverage)\n      if (r0.y < r2.y) {\n        // from above\n        yOver = (r.y + r.h - r2.y) / r2.h;\n      } else if (r0.y + r0.h > r2.y + r2.h) {\n        // from below\n        yOver = (r2.y + r2.h - r.y) / r2.h;\n      }\n      if (r0.x < r2.x) {\n        // from the left\n        xOver = (r.x + r.w - r2.x) / r2.w;\n      } else if (r0.x + r0.w > r2.x + r2.w) {\n        // from the right\n        xOver = (r2.x + r2.w - r.x) / r2.w;\n      }\n      let over = Math.min(xOver, yOver);\n      if (over > overMax) {\n        overMax = over;\n        collide = n;\n      }\n    }\n    o.collide = collide; // save it so we don't have to find it again\n    return collide;\n  }\n  /** does a pixel coverage returning the node that has the most coverage by area */\n  /*\n  protected collideCoverage(r: GridStackPosition, collides: GridStackNode[]): {collide: GridStackNode, over: number} {\n    let collide: GridStackNode;\n    let overMax = 0;\n    collides.forEach(n => {\n      if (n.locked || !n._rect) return;\n      let over = Utils.areaIntercept(r, n._rect);\n      if (over > overMax) {\n        overMax = over;\n        collide = n;\n      }\n    });\n    return {collide, over: overMax};\n  }\n  */\n  /** called to cache the nodes pixel rectangles used for collision detection during drag */\n  cacheRects(w, h, top, right, bottom, left) {\n    this.nodes.forEach(n => n._rect = {\n      y: n.y * h + top,\n      x: n.x * w + left,\n      w: n.w * w - left - right,\n      h: n.h * h - top - bottom\n    });\n    return this;\n  }\n  /** called to possibly swap between 2 nodes (same size or column, not locked, touching), returning true if successful */\n  swap(a, b) {\n    if (!b || b.locked || !a || a.locked) return false;\n    function _doSwap() {\n      let x = b.x,\n        y = b.y;\n      b.x = a.x;\n      b.y = a.y; // b -> a position\n      if (a.h != b.h) {\n        a.x = x;\n        a.y = b.y + b.h; // a -> goes after b\n      } else if (a.w != b.w) {\n        a.x = b.x + b.w;\n        a.y = y; // a -> goes after b\n      } else {\n        a.x = x;\n        a.y = y; // a -> old b position\n      }\n      a._dirty = b._dirty = true;\n      return true;\n    }\n    let touching; // remember if we called it (vs undefined)\n    // same size and same row or column, and touching\n    if (a.w === b.w && a.h === b.h && (a.x === b.x || a.y === b.y) && (touching = Utils.isTouching(a, b))) return _doSwap();\n    if (touching === false) return; // IFF ran test and fail, bail out\n    // check for taking same columns (but different height) and touching\n    if (a.w === b.w && a.x === b.x && (touching || (touching = Utils.isTouching(a, b)))) {\n      if (b.y < a.y) {\n        let t = a;\n        a = b;\n        b = t;\n      } // swap a <-> b vars so a is first\n      return _doSwap();\n    }\n    if (touching === false) return;\n    // check if taking same row (but different width) and touching\n    if (a.h === b.h && a.y === b.y && (touching || (touching = Utils.isTouching(a, b)))) {\n      if (b.x < a.x) {\n        let t = a;\n        a = b;\n        b = t;\n      } // swap a <-> b vars so a is first\n      return _doSwap();\n    }\n    return false;\n  }\n  isAreaEmpty(x, y, w, h) {\n    let nn = {\n      x: x || 0,\n      y: y || 0,\n      w: w || 1,\n      h: h || 1\n    };\n    return !this.collide(nn);\n  }\n  /** re-layout grid items to reclaim any empty space - optionally keeping the sort order exactly the same ('list' mode) vs truly finding an empty spaces */\n  compact(layout = 'compact', doSort = true) {\n    if (this.nodes.length === 0) return this;\n    if (doSort) this.sortNodes();\n    const wasBatch = this.batchMode;\n    if (!wasBatch) this.batchUpdate();\n    const wasColumnResize = this._inColumnResize;\n    if (!wasColumnResize) this._inColumnResize = true; // faster addNode()\n    let copyNodes = this.nodes;\n    this.nodes = []; // pretend we have no nodes to conflict layout to start with...\n    copyNodes.forEach((n, index, list) => {\n      let after;\n      if (!n.locked) {\n        n.autoPosition = true;\n        if (layout === 'list' && index) after = list[index - 1];\n      }\n      this.addNode(n, false, after); // 'false' for add event trigger\n    });\n    if (!wasColumnResize) delete this._inColumnResize;\n    if (!wasBatch) this.batchUpdate(false);\n    return this;\n  }\n  /** enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html) */\n  set float(val) {\n    if (this._float === val) return;\n    this._float = val || false;\n    if (!val) {\n      this._packNodes()._notify();\n    }\n  }\n  /** float getter method */\n  get float() {\n    return this._float || false;\n  }\n  /** sort the nodes array from first to last, or reverse. Called during collision/placement to force an order */\n  sortNodes(dir = 1) {\n    this.nodes = Utils.sort(this.nodes, dir);\n    return this;\n  }\n  /** @internal called to top gravity pack the items back OR revert back to original Y positions when floating */\n  _packNodes() {\n    if (this.batchMode) {\n      return this;\n    }\n    this.sortNodes(); // first to last\n    if (this.float) {\n      // restore original Y pos\n      this.nodes.forEach(n => {\n        if (n._updating || n._orig === undefined || n.y === n._orig.y) return;\n        let newY = n.y;\n        while (newY > n._orig.y) {\n          --newY;\n          let collide = this.collide(n, {\n            x: n.x,\n            y: newY,\n            w: n.w,\n            h: n.h\n          });\n          if (!collide) {\n            n._dirty = true;\n            n.y = newY;\n          }\n        }\n      });\n    } else {\n      // top gravity pack\n      this.nodes.forEach((n, i) => {\n        if (n.locked) return;\n        while (n.y > 0) {\n          let newY = i === 0 ? 0 : n.y - 1;\n          let canBeMoved = i === 0 || !this.collide(n, {\n            x: n.x,\n            y: newY,\n            w: n.w,\n            h: n.h\n          });\n          if (!canBeMoved) break;\n          // Note: must be dirty (from last position) for GridStack::OnChange CB to update positions\n          // and move items back. The user 'change' CB should detect changes from the original\n          // starting position instead.\n          n._dirty = n.y !== newY;\n          n.y = newY;\n        }\n      });\n    }\n    return this;\n  }\n  /**\n   * given a random node, makes sure it's coordinates/values are valid in the current grid\n   * @param node to adjust\n   * @param resizing if out of bound, resize down or move into the grid to fit ?\n   */\n  prepareNode(node, resizing) {\n    node._id = node._id ?? GridStackEngine._idSeq++;\n    // if we're missing position, have the grid position us automatically (before we set them to 0,0)\n    if (node.x === undefined || node.y === undefined || node.x === null || node.y === null) {\n      node.autoPosition = true;\n    }\n    // assign defaults for missing required fields\n    let defaults = {\n      x: 0,\n      y: 0,\n      w: 1,\n      h: 1\n    };\n    Utils.defaults(node, defaults);\n    if (!node.autoPosition) {\n      delete node.autoPosition;\n    }\n    if (!node.noResize) {\n      delete node.noResize;\n    }\n    if (!node.noMove) {\n      delete node.noMove;\n    }\n    Utils.sanitizeMinMax(node);\n    // check for NaN (in case messed up strings were passed. can't do parseInt() || defaults.x above as 0 is valid #)\n    if (typeof node.x == 'string') {\n      node.x = Number(node.x);\n    }\n    if (typeof node.y == 'string') {\n      node.y = Number(node.y);\n    }\n    if (typeof node.w == 'string') {\n      node.w = Number(node.w);\n    }\n    if (typeof node.h == 'string') {\n      node.h = Number(node.h);\n    }\n    if (isNaN(node.x)) {\n      node.x = defaults.x;\n      node.autoPosition = true;\n    }\n    if (isNaN(node.y)) {\n      node.y = defaults.y;\n      node.autoPosition = true;\n    }\n    if (isNaN(node.w)) {\n      node.w = defaults.w;\n    }\n    if (isNaN(node.h)) {\n      node.h = defaults.h;\n    }\n    this.nodeBoundFix(node, resizing);\n    return node;\n  }\n  /** part2 of preparing a node to fit inside our grid - checks for x,y,w from grid dimensions */\n  nodeBoundFix(node, resizing) {\n    let before = node._orig || Utils.copyPos({}, node);\n    if (node.maxW) {\n      node.w = Math.min(node.w, node.maxW);\n    }\n    if (node.maxH) {\n      node.h = Math.min(node.h, node.maxH);\n    }\n    if (node.minW && node.minW <= this.column) {\n      node.w = Math.max(node.w, node.minW);\n    }\n    if (node.minH) {\n      node.h = Math.max(node.h, node.minH);\n    }\n    // if user loaded a larger than allowed widget for current # of columns,\n    // remember it's position & width so we can restore back (1 -> 12 column) #1655 #1985\n    // IFF we're not in the middle of column resizing!\n    const saveOrig = (node.x || 0) + (node.w || 1) > this.column;\n    if (saveOrig && this.column < 12 && !this._inColumnResize && node._id && this.findCacheLayout(node, 12) === -1) {\n      let copy = {\n        ...node\n      }; // need _id + positions\n      if (copy.autoPosition || copy.x === undefined) {\n        delete copy.x;\n        delete copy.y;\n      } else copy.x = Math.min(11, copy.x);\n      copy.w = Math.min(12, copy.w || 1);\n      this.cacheOneLayout(copy, 12);\n    }\n    if (node.w > this.column) {\n      node.w = this.column;\n    } else if (node.w < 1) {\n      node.w = 1;\n    }\n    if (this.maxRow && node.h > this.maxRow) {\n      node.h = this.maxRow;\n    } else if (node.h < 1) {\n      node.h = 1;\n    }\n    if (node.x < 0) {\n      node.x = 0;\n    }\n    if (node.y < 0) {\n      node.y = 0;\n    }\n    if (node.x + node.w > this.column) {\n      if (resizing) {\n        node.w = this.column - node.x;\n      } else {\n        node.x = this.column - node.w;\n      }\n    }\n    if (this.maxRow && node.y + node.h > this.maxRow) {\n      if (resizing) {\n        node.h = this.maxRow - node.y;\n      } else {\n        node.y = this.maxRow - node.h;\n      }\n    }\n    if (!Utils.samePos(node, before)) {\n      node._dirty = true;\n    }\n    return this;\n  }\n  /** returns a list of modified nodes from their original values */\n  getDirtyNodes(verify) {\n    // compare original x,y,w,h instead as _dirty can be a temporary state\n    if (verify) {\n      return this.nodes.filter(n => n._dirty && !Utils.samePos(n, n._orig));\n    }\n    return this.nodes.filter(n => n._dirty);\n  }\n  /** @internal call this to call onChange callback with dirty nodes so DOM can be updated */\n  _notify(removedNodes) {\n    if (this.batchMode || !this.onChange) return this;\n    let dirtyNodes = (removedNodes || []).concat(this.getDirtyNodes());\n    this.onChange(dirtyNodes);\n    return this;\n  }\n  /** @internal remove dirty and last tried info */\n  cleanNodes() {\n    if (this.batchMode) return this;\n    this.nodes.forEach(n => {\n      delete n._dirty;\n      delete n._lastTried;\n    });\n    return this;\n  }\n  /** @internal called to save initial position/size to track real dirty state.\n   * Note: should be called right after we call change event (so next API is can detect changes)\n   * as well as right before we start move/resize/enter (so we can restore items to prev values) */\n  saveInitial() {\n    this.nodes.forEach(n => {\n      n._orig = Utils.copyPos({}, n);\n      delete n._dirty;\n    });\n    this._hasLocked = this.nodes.some(n => n.locked);\n    return this;\n  }\n  /** @internal restore all the nodes back to initial values (called when we leave) */\n  restoreInitial() {\n    this.nodes.forEach(n => {\n      if (Utils.samePos(n, n._orig)) return;\n      Utils.copyPos(n, n._orig);\n      n._dirty = true;\n    });\n    this._notify();\n    return this;\n  }\n  /** find the first available empty spot for the given node width/height, updating the x,y attributes. return true if found.\n   * optionally you can pass your own existing node list and column count, otherwise defaults to that engine data.\n   * Optionally pass a widget to start search AFTER, meaning the order will remain the same but possibly have empty slots we skipped\n   */\n  findEmptyPosition(node, nodeList = this.nodes, column = this.column, after) {\n    let start = after ? after.y * column + (after.x + after.w) : 0;\n    let found = false;\n    for (let i = start; !found; ++i) {\n      let x = i % column;\n      let y = Math.floor(i / column);\n      if (x + node.w > column) {\n        continue;\n      }\n      let box = {\n        x,\n        y,\n        w: node.w,\n        h: node.h\n      };\n      if (!nodeList.find(n => Utils.isIntercepted(box, n))) {\n        if (node.x !== x || node.y !== y) node._dirty = true;\n        node.x = x;\n        node.y = y;\n        delete node.autoPosition;\n        found = true;\n      }\n    }\n    return found;\n  }\n  /** call to add the given node to our list, fixing collision and re-packing */\n  addNode(node, triggerAddEvent = false, after) {\n    let dup = this.nodes.find(n => n._id === node._id);\n    if (dup) return dup; // prevent inserting twice! return it instead.\n    // skip prepareNode if we're in middle of column resize (not new) but do check for bounds!\n    this._inColumnResize ? this.nodeBoundFix(node) : this.prepareNode(node);\n    delete node._temporaryRemoved;\n    delete node._removeDOM;\n    let skipCollision;\n    if (node.autoPosition && this.findEmptyPosition(node, this.nodes, this.column, after)) {\n      delete node.autoPosition; // found our slot\n      skipCollision = true;\n    }\n    this.nodes.push(node);\n    if (triggerAddEvent) {\n      this.addedNodes.push(node);\n    }\n    if (!skipCollision) this._fixCollisions(node);\n    if (!this.batchMode) {\n      this._packNodes()._notify();\n    }\n    return node;\n  }\n  removeNode(node, removeDOM = true, triggerEvent = false) {\n    if (!this.nodes.find(n => n._id === node._id)) {\n      // TEST console.log(`Error: GridStackEngine.removeNode() node._id=${node._id} not found!`)\n      return this;\n    }\n    if (triggerEvent) {\n      // we wait until final drop to manually track removed items (rather than during drag)\n      this.removedNodes.push(node);\n    }\n    if (removeDOM) node._removeDOM = true; // let CB remove actual HTML (used to set _id to null, but then we loose layout info)\n    // don't use 'faster' .splice(findIndex(),1) in case node isn't in our list, or in multiple times.\n    this.nodes = this.nodes.filter(n => n._id !== node._id);\n    if (!node._isAboutToRemove) this._packNodes(); // if dragged out, no need to relayout as already done...\n    this._notify([node]);\n    return this;\n  }\n  removeAll(removeDOM = true, triggerEvent = true) {\n    delete this._layouts;\n    if (!this.nodes.length) return this;\n    removeDOM && this.nodes.forEach(n => n._removeDOM = true); // let CB remove actual HTML (used to set _id to null, but then we loose layout info)\n    const removedNodes = this.nodes;\n    this.removedNodes = triggerEvent ? removedNodes : [];\n    this.nodes = [];\n    return this._notify(removedNodes);\n  }\n  /** checks if item can be moved (layout constrain) vs moveNode(), returning true if was able to move.\n   * In more complicated cases (maxRow) it will attempt at moving the item and fixing\n   * others in a clone first, then apply those changes if still within specs. */\n  moveNodeCheck(node, o) {\n    // if (node.locked) return false;\n    if (!this.changedPosConstrain(node, o)) return false;\n    o.pack = true;\n    // simpler case: move item directly...\n    if (!this.maxRow) {\n      return this.moveNode(node, o);\n    }\n    // complex case: create a clone with NO maxRow (will check for out of bounds at the end)\n    let clonedNode;\n    let clone = new GridStackEngine({\n      column: this.column,\n      float: this.float,\n      nodes: this.nodes.map(n => {\n        if (n._id === node._id) {\n          clonedNode = {\n            ...n\n          };\n          return clonedNode;\n        }\n        return {\n          ...n\n        };\n      })\n    });\n    if (!clonedNode) return false;\n    // check if we're covering 50% collision and could move, while still being under maxRow or at least not making it worse\n    // (case where widget was somehow added past our max #2449)\n    let canMove = clone.moveNode(clonedNode, o) && clone.getRow() <= Math.max(this.getRow(), this.maxRow);\n    // else check if we can force a swap (float=true, or different shapes) on non-resize\n    if (!canMove && !o.resizing && o.collide) {\n      let collide = o.collide.el.gridstackNode; // find the source node the clone collided with at 50%\n      if (this.swap(node, collide)) {\n        // swaps and mark dirty\n        this._notify();\n        return true;\n      }\n    }\n    if (!canMove) return false;\n    // if clone was able to move, copy those mods over to us now instead of caller trying to do this all over!\n    // Note: we can't use the list directly as elements and other parts point to actual node, so copy content\n    clone.nodes.filter(n => n._dirty).forEach(c => {\n      let n = this.nodes.find(a => a._id === c._id);\n      if (!n) return;\n      Utils.copyPos(n, c);\n      n._dirty = true;\n    });\n    this._notify();\n    return true;\n  }\n  /** return true if can fit in grid height constrain only (always true if no maxRow) */\n  willItFit(node) {\n    delete node._willFitPos;\n    if (!this.maxRow) return true;\n    // create a clone with NO maxRow and check if still within size\n    let clone = new GridStackEngine({\n      column: this.column,\n      float: this.float,\n      nodes: this.nodes.map(n => {\n        return {\n          ...n\n        };\n      })\n    });\n    let n = {\n      ...node\n    }; // clone node so we don't mod any settings on it but have full autoPosition and min/max as well! #1687\n    this.cleanupNode(n);\n    delete n.el;\n    delete n._id;\n    delete n.content;\n    delete n.grid;\n    clone.addNode(n);\n    if (clone.getRow() <= this.maxRow) {\n      node._willFitPos = Utils.copyPos({}, n);\n      return true;\n    }\n    return false;\n  }\n  /** true if x,y or w,h are different after clamping to min/max */\n  changedPosConstrain(node, p) {\n    // first make sure w,h are set for caller\n    p.w = p.w || node.w;\n    p.h = p.h || node.h;\n    if (node.x !== p.x || node.y !== p.y) return true;\n    // check constrained w,h\n    if (node.maxW) {\n      p.w = Math.min(p.w, node.maxW);\n    }\n    if (node.maxH) {\n      p.h = Math.min(p.h, node.maxH);\n    }\n    if (node.minW) {\n      p.w = Math.max(p.w, node.minW);\n    }\n    if (node.minH) {\n      p.h = Math.max(p.h, node.minH);\n    }\n    return node.w !== p.w || node.h !== p.h;\n  }\n  /** return true if the passed in node was actually moved (checks for no-op and locked) */\n  moveNode(node, o) {\n    if (!node || /*node.locked ||*/!o) return false;\n    let wasUndefinedPack;\n    if (o.pack === undefined && !this.batchMode) {\n      wasUndefinedPack = o.pack = true;\n    }\n    // constrain the passed in values and check if we're still changing our node\n    if (typeof o.x !== 'number') {\n      o.x = node.x;\n    }\n    if (typeof o.y !== 'number') {\n      o.y = node.y;\n    }\n    if (typeof o.w !== 'number') {\n      o.w = node.w;\n    }\n    if (typeof o.h !== 'number') {\n      o.h = node.h;\n    }\n    let resizing = node.w !== o.w || node.h !== o.h;\n    let nn = Utils.copyPos({}, node, true); // get min/max out first, then opt positions next\n    Utils.copyPos(nn, o);\n    this.nodeBoundFix(nn, resizing);\n    Utils.copyPos(o, nn);\n    if (!o.forceCollide && Utils.samePos(node, o)) return false;\n    let prevPos = Utils.copyPos({}, node);\n    // check if we will need to fix collision at our new location\n    let collides = this.collideAll(node, nn, o.skip);\n    let needToMove = true;\n    if (collides.length) {\n      let activeDrag = node._moving && !o.nested;\n      // check to make sure we actually collided over 50% surface area while dragging\n      let collide = activeDrag ? this.directionCollideCoverage(node, o, collides) : collides[0];\n      // if we're enabling creation of sub-grids on the fly, see if we're covering 80% of either one, if we didn't already do that\n      if (activeDrag && collide && node.grid?.opts?.subGridDynamic && !node.grid._isTemp) {\n        let over = Utils.areaIntercept(o.rect, collide._rect);\n        let a1 = Utils.area(o.rect);\n        let a2 = Utils.area(collide._rect);\n        let perc = over / (a1 < a2 ? a1 : a2);\n        if (perc > .8) {\n          collide.grid.makeSubGrid(collide.el, undefined, node);\n          collide = undefined;\n        }\n      }\n      if (collide) {\n        needToMove = !this._fixCollisions(node, nn, collide, o); // check if already moved...\n      } else {\n        needToMove = false; // we didn't cover >50% for a move, skip...\n        if (wasUndefinedPack) delete o.pack;\n      }\n    }\n    // now move (to the original ask vs the collision version which might differ) and repack things\n    if (needToMove) {\n      node._dirty = true;\n      Utils.copyPos(node, nn);\n    }\n    if (o.pack) {\n      this._packNodes()._notify();\n    }\n    return !Utils.samePos(node, prevPos); // pack might have moved things back\n  }\n  getRow() {\n    return this.nodes.reduce((row, n) => Math.max(row, n.y + n.h), 0);\n  }\n  beginUpdate(node) {\n    if (!node._updating) {\n      node._updating = true;\n      delete node._skipDown;\n      if (!this.batchMode) this.saveInitial();\n    }\n    return this;\n  }\n  endUpdate() {\n    let n = this.nodes.find(n => n._updating);\n    if (n) {\n      delete n._updating;\n      delete n._skipDown;\n    }\n    return this;\n  }\n  /** saves a copy of the largest column layout (eg 12 even when rendering oneColumnMode) so we don't loose orig layout,\n   * returning a list of widgets for serialization */\n  save(saveElement = true, saveCB) {\n    // use the highest layout for any saved info so we can have full detail on reload #1849\n    let len = this._layouts?.length;\n    let layout = len && this.column !== len - 1 ? this._layouts[len - 1] : null;\n    let list = [];\n    this.sortNodes();\n    this.nodes.forEach(n => {\n      let wl = layout?.find(l => l._id === n._id);\n      // use layout info fields instead if set\n      let w = {\n        ...n,\n        ...(wl || {})\n      };\n      Utils.removeInternalForSave(w, !saveElement);\n      if (saveCB) saveCB(n, w);\n      list.push(w);\n    });\n    return list;\n  }\n  /** @internal called whenever a node is added or moved - updates the cached layouts */\n  layoutsNodesChange(nodes) {\n    if (!this._layouts || this._inColumnResize) return this;\n    // remove smaller layouts - we will re-generate those on the fly... larger ones need to update\n    this._layouts.forEach((layout, column) => {\n      if (!layout || column === this.column) return this;\n      if (column < this.column) {\n        this._layouts[column] = undefined;\n      } else {\n        // we save the original x,y,w (h isn't cached) to see what actually changed to propagate better.\n        // NOTE: we don't need to check against out of bound scaling/moving as that will be done when using those cache values. #1785\n        let ratio = column / this.column;\n        nodes.forEach(node => {\n          if (!node._orig) return; // didn't change (newly added ?)\n          let n = layout.find(l => l._id === node._id);\n          if (!n) return; // no cache for new nodes. Will use those values.\n          // Y changed, push down same amount\n          // TODO: detect doing item 'swaps' will help instead of move (especially in 1 column mode)\n          if (n.y >= 0 && node.y !== node._orig.y) {\n            n.y += node.y - node._orig.y;\n          }\n          // X changed, scale from new position\n          if (node.x !== node._orig.x) {\n            n.x = Math.round(node.x * ratio);\n          }\n          // width changed, scale from new width\n          if (node.w !== node._orig.w) {\n            n.w = Math.round(node.w * ratio);\n          }\n          // ...height always carries over from cache\n        });\n      }\n    });\n    return this;\n  }\n  /**\n   * @internal Called to scale the widget width & position up/down based on the column change.\n   * Note we store previous layouts (especially original ones) to make it possible to go\n   * from say 12 -> 1 -> 12 and get back to where we were.\n   *\n   * @param prevColumn previous number of columns\n   * @param column  new column number\n   * @param layout specify the type of re-layout that will happen (position, size, etc...).\n   * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column\n   */\n  columnChanged(prevColumn, column, layout = 'moveScale') {\n    if (!this.nodes.length || !column || prevColumn === column) return this;\n    // in this mode no layout is done whatsoever, up to the caller to handle it\n    if (layout === 'none') return this;\n    // simpler shortcuts layouts\n    const doCompact = layout === 'compact' || layout === 'list';\n    if (doCompact) {\n      this.sortNodes(1); // sort with original layout once and only once (new column will affect order otherwise)\n    }\n    // cache the current layout in case they want to go back (like 12 -> 1 -> 12) as it requires original data IFF we're sizing down (see below)\n    if (column < prevColumn) this.cacheLayout(this.nodes, prevColumn);\n    this.batchUpdate(); // do this EARLY as it will call saveInitial() so we can detect where we started for _dirty and collision\n    let newNodes = [];\n    let nodes = doCompact ? this.nodes : Utils.sort(this.nodes, -1); // current column reverse sorting so we can insert last to front (limit collision)\n    // see if we have cached previous layout IFF we are going up in size (restore) otherwise always\n    // generate next size down from where we are (looks more natural as you gradually size down).\n    if (column > prevColumn && this._layouts) {\n      const cacheNodes = this._layouts[column] || [];\n      // ...if not, start with the largest layout (if not already there) as down-scaling is more accurate\n      // by pretending we came from that larger column by assigning those values as starting point\n      let lastIndex = this._layouts.length - 1;\n      if (!cacheNodes.length && prevColumn !== lastIndex && this._layouts[lastIndex]?.length) {\n        prevColumn = lastIndex;\n        this._layouts[lastIndex].forEach(cacheNode => {\n          let n = nodes.find(n => n._id === cacheNode._id);\n          if (n) {\n            // still current, use cache info positions\n            if (!doCompact && !cacheNode.autoPosition) {\n              n.x = cacheNode.x ?? n.x;\n              n.y = cacheNode.y ?? n.y;\n            }\n            n.w = cacheNode.w ?? n.w;\n            if (cacheNode.x == undefined || cacheNode.y === undefined) n.autoPosition = true;\n          }\n        });\n      }\n      // if we found cache re-use those nodes that are still current\n      cacheNodes.forEach(cacheNode => {\n        let j = nodes.findIndex(n => n._id === cacheNode._id);\n        if (j !== -1) {\n          const n = nodes[j];\n          // still current, use cache info positions\n          if (doCompact) {\n            n.w = cacheNode.w; // only w is used, and don't trim the list\n            return;\n          }\n          if (cacheNode.autoPosition || isNaN(cacheNode.x) || isNaN(cacheNode.y)) {\n            this.findEmptyPosition(cacheNode, newNodes);\n          }\n          if (!cacheNode.autoPosition) {\n            n.x = cacheNode.x ?? n.x;\n            n.y = cacheNode.y ?? n.y;\n            n.w = cacheNode.w ?? n.w;\n            newNodes.push(n);\n          }\n          nodes.splice(j, 1);\n        }\n      });\n    }\n    // much simpler layout that just compacts\n    if (doCompact) {\n      this.compact(layout, false);\n    } else {\n      // ...and add any extra non-cached ones\n      if (nodes.length) {\n        if (typeof layout === 'function') {\n          layout(column, prevColumn, newNodes, nodes);\n        } else {\n          let ratio = doCompact ? 1 : column / prevColumn;\n          let move = layout === 'move' || layout === 'moveScale';\n          let scale = layout === 'scale' || layout === 'moveScale';\n          nodes.forEach(node => {\n            // NOTE: x + w could be outside of the grid, but addNode() below will handle that\n            node.x = column === 1 ? 0 : move ? Math.round(node.x * ratio) : Math.min(node.x, column - 1);\n            node.w = column === 1 || prevColumn === 1 ? 1 : scale ? Math.round(node.w * ratio) || 1 : Math.min(node.w, column);\n            newNodes.push(node);\n          });\n          nodes = [];\n        }\n      }\n      // finally re-layout them in reverse order (to get correct placement)\n      newNodes = Utils.sort(newNodes, -1);\n      this._inColumnResize = true; // prevent cache update\n      this.nodes = []; // pretend we have no nodes to start with (add() will use same structures) to simplify layout\n      newNodes.forEach(node => {\n        this.addNode(node, false); // 'false' for add event trigger\n        delete node._orig; // make sure the commit doesn't try to restore things back to original\n      });\n    }\n    this.nodes.forEach(n => delete n._orig); // clear _orig before batch=false so it doesn't handle float=true restore\n    this.batchUpdate(false, !doCompact);\n    delete this._inColumnResize;\n    return this;\n  }\n  /**\n   * call to cache the given layout internally to the given location so we can restore back when column changes size\n   * @param nodes list of nodes\n   * @param column corresponding column index to save it under\n   * @param clear if true, will force other caches to be removed (default false)\n   */\n  cacheLayout(nodes, column, clear = false) {\n    let copy = [];\n    nodes.forEach((n, i) => {\n      // make sure we have an id in case this is new layout, else re-use id already set\n      if (n._id === undefined) {\n        const existing = n.id ? this.nodes.find(n2 => n2.id === n.id) : undefined; // find existing node using users id\n        n._id = existing?._id ?? GridStackEngine._idSeq++;\n      }\n      copy[i] = {\n        x: n.x,\n        y: n.y,\n        w: n.w,\n        _id: n._id\n      }; // only thing we change is x,y,w and id to find it back\n    });\n    this._layouts = clear ? [] : this._layouts || []; // use array to find larger quick\n    this._layouts[column] = copy;\n    return this;\n  }\n  /**\n   * call to cache the given node layout internally to the given location so we can restore back when column changes size\n   * @param node single node to cache\n   * @param column corresponding column index to save it under\n   */\n  cacheOneLayout(n, column) {\n    n._id = n._id ?? GridStackEngine._idSeq++;\n    let l = {\n      x: n.x,\n      y: n.y,\n      w: n.w,\n      _id: n._id\n    };\n    if (n.autoPosition || n.x === undefined) {\n      delete l.x;\n      delete l.y;\n      if (n.autoPosition) l.autoPosition = true;\n    }\n    this._layouts = this._layouts || [];\n    this._layouts[column] = this._layouts[column] || [];\n    let index = this.findCacheLayout(n, column);\n    if (index === -1) this._layouts[column].push(l);else this._layouts[column][index] = l;\n    return this;\n  }\n  findCacheLayout(n, column) {\n    return this._layouts?.[column]?.findIndex(l => l._id === n._id) ?? -1;\n  }\n  removeNodeFromLayoutCache(n) {\n    if (!this._layouts) {\n      return;\n    }\n    for (let i = 0; i < this._layouts.length; i++) {\n      let index = this.findCacheLayout(n, i);\n      if (index !== -1) {\n        this._layouts[i].splice(index, 1);\n      }\n    }\n  }\n  /** called to remove all internal values but the _id */\n  cleanupNode(node) {\n    for (let prop in node) {\n      if (prop[0] === '_' && prop !== '_id') delete node[prop];\n    }\n    return this;\n  }\n}\n/** @internal unique global internal _id counter */\nGridStackEngine._idSeq = 0;\nexport { GridStackEngine };","map":{"version":3,"names":["Utils","GridStackEngine","constructor","opts","addedNodes","removedNodes","column","maxRow","_float","float","nodes","onChange","batchUpdate","flag","doPack","batchMode","_prevFloat","cleanNodes","saveInitial","_packNodes","_notify","_useEntireRowArea","node","nn","_hasLocked","_moving","_skipDown","y","_fixCollisions","collide","opt","sortNodes","nested","swap","area","_loading","x","w","h","skip","didMove","newOpt","pack","moved","locked","moveNode","copyPos","undefined","skip2","skipId","_id","skip2Id","find","n","isIntercepted","collideAll","filter","directionCollideCoverage","o","collides","rect","_rect","r0","r","overMax","r2","yOver","Number","MAX_VALUE","xOver","over","Math","min","cacheRects","top","right","bottom","left","forEach","a","b","_doSwap","_dirty","touching","isTouching","t","isAreaEmpty","compact","layout","doSort","length","wasBatch","wasColumnResize","_inColumnResize","copyNodes","index","list","after","autoPosition","addNode","val","dir","sort","_updating","_orig","newY","i","canBeMoved","prepareNode","resizing","_idSeq","defaults","noResize","noMove","sanitizeMinMax","isNaN","nodeBoundFix","before","maxW","maxH","minW","max","minH","saveOrig","findCacheLayout","copy","cacheOneLayout","samePos","getDirtyNodes","verify","dirtyNodes","concat","_lastTried","some","restoreInitial","findEmptyPosition","nodeList","start","found","floor","box","triggerAddEvent","dup","_temporaryRemoved","_removeDOM","skipCollision","push","removeNode","removeDOM","triggerEvent","_isAboutToRemove","removeAll","_layouts","moveNodeCheck","changedPosConstrain","clonedNode","clone","map","canMove","getRow","el","gridstackNode","c","willItFit","_willFitPos","cleanupNode","content","grid","p","wasUndefinedPack","forceCollide","prevPos","needToMove","activeDrag","subGridDynamic","_isTemp","areaIntercept","a1","a2","perc","makeSubGrid","reduce","row","beginUpdate","endUpdate","save","saveElement","saveCB","len","wl","l","removeInternalForSave","layoutsNodesChange","ratio","round","columnChanged","prevColumn","doCompact","cacheLayout","newNodes","cacheNodes","lastIndex","cacheNode","j","findIndex","splice","move","scale","clear","existing","id","n2","removeNodeFromLayoutCache","prop"],"sources":["../src/gridstack-engine.ts"],"sourcesContent":["/**\n * gridstack-engine.ts 10.3.1\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */\n\nimport { Utils } from './utils';\nimport { GridStackNode, ColumnOptions, GridStackPosition, GridStackMoveOpts, SaveFcn, CompactOptions } from './types';\n\n/** callback to update the DOM attributes since this class is generic (no HTML or other info) for items that changed - see _notify() */\ntype OnChangeCB = (nodes: GridStackNode[]) => void;\n\n/** options used during creation - similar to GridStackOptions */\nexport interface GridStackEngineOptions {\n  column?: number;\n  maxRow?: number;\n  float?: boolean;\n  nodes?: GridStackNode[];\n  onChange?: OnChangeCB;\n}\n\n/**\n * Defines the GridStack engine that does most no DOM grid manipulation.\n * See GridStack methods and vars for descriptions.\n *\n * NOTE: values should not be modified directly - call the main GridStack API instead\n */\nexport class GridStackEngine {\n  public column: number;\n  public maxRow: number;\n  public nodes: GridStackNode[];\n  public addedNodes: GridStackNode[] = [];\n  public removedNodes: GridStackNode[] = [];\n  public batchMode: boolean;\n  /** @internal callback to update the DOM attributes */\n  protected onChange: OnChangeCB;\n  /** @internal */\n  protected _float: boolean;\n  /** @internal */\n  protected _prevFloat: boolean;\n  /** @internal cached layouts of difference column count so we can restore back (eg 12 -> 1 -> 12) */\n  protected _layouts?: GridStackNode[][]; // maps column # to array of values nodes\n  /** @internal set during loading (which is sorted) so item gets added AFTER collision nodes */\n  public _loading?: boolean\n  /** @internal true while we are resizing widgets during column resize to skip certain parts */\n  protected _inColumnResize?: boolean;\n  /** @internal true if we have some items locked */\n  protected _hasLocked: boolean;\n  /** @internal unique global internal _id counter */\n  public static _idSeq = 0;\n\n  public constructor(opts: GridStackEngineOptions = {}) {\n    this.column = opts.column || 12;\n    this.maxRow = opts.maxRow;\n    this._float = opts.float;\n    this.nodes = opts.nodes || [];\n    this.onChange = opts.onChange;\n  }\n\n  public batchUpdate(flag = true, doPack = true): GridStackEngine {\n    if (!!this.batchMode === flag) return this;\n    this.batchMode = flag;\n    if (flag) {\n      this._prevFloat = this._float;\n      this._float = true; // let things go anywhere for now... will restore and possibly reposition later\n      this.cleanNodes();\n      this.saveInitial(); // since begin update (which is called multiple times) won't do this\n    } else {\n      this._float = this._prevFloat;\n      delete this._prevFloat;\n      if (doPack) this._packNodes();\n      this._notify();\n    }\n    return this;\n  }\n\n  // use entire row for hitting area (will use bottom reverse sorted first) if we not actively moving DOWN and didn't already skip\n  protected _useEntireRowArea(node: GridStackNode, nn: GridStackPosition): boolean {\n    return (!this.float || this.batchMode && !this._prevFloat) && !this._hasLocked && (!node._moving || node._skipDown || nn.y <= node.y);\n  }\n\n  /** @internal fix collision on given 'node', going to given new location 'nn', with optional 'collide' node already found.\n   * return true if we moved. */\n  protected _fixCollisions(node: GridStackNode, nn = node, collide?: GridStackNode, opt: GridStackMoveOpts = {}): boolean {\n    this.sortNodes(-1); // from last to first, so recursive collision move items in the right order\n\n    collide = collide || this.collide(node, nn); // REAL area collide for swap and skip if none...\n    if (!collide) return false;\n\n    // swap check: if we're actively moving in gravity mode, see if we collide with an object the same size\n    if (node._moving && !opt.nested && !this.float) {\n      if (this.swap(node, collide)) return true;\n    }\n\n    // during while() collisions MAKE SURE to check entire row so larger items don't leap frog small ones (push them all down starting last in grid)\n    let area = nn;\n    if (!this._loading && this._useEntireRowArea(node, nn)) {\n      area = {x: 0, w: this.column, y: nn.y, h: nn.h};\n      collide = this.collide(node, area, opt.skip); // force new hit\n    }\n\n    let didMove = false;\n    let newOpt: GridStackMoveOpts = {nested: true, pack: false};\n    while (collide = collide || this.collide(node, area, opt.skip)) { // could collide with more than 1 item... so repeat for each\n      let moved: boolean;\n      // if colliding with a locked item OR loading (move after) OR moving down with top gravity (and collide could move up) -> skip past the collide,\n      // but remember that skip down so we only do this once (and push others otherwise).\n      if (collide.locked || this._loading || node._moving && !node._skipDown && nn.y > node.y && !this.float &&\n        // can take space we had, or before where we're going\n        (!this.collide(collide, {...collide, y: node.y}, node) || !this.collide(collide, {...collide, y: nn.y - collide.h}, node))) {\n        node._skipDown = (node._skipDown || nn.y > node.y);\n        moved = this.moveNode(node, {...nn, y: collide.y + collide.h, ...newOpt});\n        if ((collide.locked || this._loading) && moved) {\n          Utils.copyPos(nn, node); // moving after lock become our new desired location\n        } else if (!collide.locked && moved && opt.pack) {\n          // we moved after and will pack: do it now and keep the original drop location, but past the old collide to see what else we might push way\n          this._packNodes();\n          nn.y = collide.y + collide.h;\n          Utils.copyPos(node, nn);\n        }\n        didMove = didMove || moved;\n      } else {\n        // move collide down *after* where we will be, ignoring where we are now (don't collide with us)\n        moved = this.moveNode(collide, {...collide, y: nn.y + nn.h, skip: node, ...newOpt});\n      }\n      if (!moved) { return didMove; } // break inf loop if we couldn't move after all (ex: maxRow, fixed)\n      collide = undefined;\n    }\n    return didMove;\n  }\n\n  /** return the nodes that intercept the given node. Optionally a different area can be used, as well as a second node to skip */\n  public collide(skip: GridStackNode, area = skip, skip2?: GridStackNode): GridStackNode | undefined {\n    const skipId = skip._id;\n    const skip2Id = skip2?._id;\n    return this.nodes.find(n => n._id !== skipId && n._id !== skip2Id && Utils.isIntercepted(n, area));\n  }\n  public collideAll(skip: GridStackNode, area = skip, skip2?: GridStackNode): GridStackNode[] {\n    const skipId = skip._id;\n    const skip2Id = skip2?._id;\n    return this.nodes.filter(n => n._id !== skipId && n._id !== skip2Id && Utils.isIntercepted(n, area));\n  }\n\n  /** does a pixel coverage collision based on where we started, returning the node that has the most coverage that is >50% mid line */\n  protected directionCollideCoverage(node: GridStackNode, o: GridStackMoveOpts, collides: GridStackNode[]): GridStackNode | undefined {\n    if (!o.rect || !node._rect) return;\n    let r0 = node._rect; // where started\n    let r = {...o.rect}; // where we are\n\n    // update dragged rect to show where it's coming from (above or below, etc...)\n    if (r.y > r0.y) {\n      r.h += r.y - r0.y;\n      r.y = r0.y;\n    } else {\n      r.h += r0.y - r.y;\n    }\n    if (r.x > r0.x) {\n      r.w += r.x - r0.x;\n      r.x = r0.x;\n    } else {\n      r.w += r0.x - r.x;\n    }\n\n    let collide: GridStackNode;\n    let overMax = 0.5; // need >50%\n    for (let n of collides) {\n      if (n.locked || !n._rect) {\n        break;\n      }\n      let r2 = n._rect; // overlapping target\n      let yOver = Number.MAX_VALUE, xOver = Number.MAX_VALUE;\n      // depending on which side we started from, compute the overlap % of coverage\n      // (ex: from above/below we only compute the max horizontal line coverage)\n      if (r0.y < r2.y) { // from above\n        yOver = ((r.y + r.h) - r2.y) / r2.h;\n      } else if (r0.y + r0.h > r2.y + r2.h) { // from below\n        yOver = ((r2.y + r2.h) - r.y) / r2.h;\n      }\n      if (r0.x < r2.x) { // from the left\n        xOver = ((r.x + r.w) - r2.x) / r2.w;\n      } else if (r0.x + r0.w > r2.x + r2.w) { // from the right\n        xOver = ((r2.x + r2.w) - r.x) / r2.w;\n      }\n      let over = Math.min(xOver, yOver);\n      if (over > overMax) {\n        overMax = over;\n        collide = n;\n      }\n    }\n    o.collide = collide; // save it so we don't have to find it again\n    return collide;\n  }\n\n  /** does a pixel coverage returning the node that has the most coverage by area */\n  /*\n  protected collideCoverage(r: GridStackPosition, collides: GridStackNode[]): {collide: GridStackNode, over: number} {\n    let collide: GridStackNode;\n    let overMax = 0;\n    collides.forEach(n => {\n      if (n.locked || !n._rect) return;\n      let over = Utils.areaIntercept(r, n._rect);\n      if (over > overMax) {\n        overMax = over;\n        collide = n;\n      }\n    });\n    return {collide, over: overMax};\n  }\n  */\n\n  /** called to cache the nodes pixel rectangles used for collision detection during drag */\n  public cacheRects(w: number, h: number, top: number, right: number, bottom: number, left: number): GridStackEngine\n  {\n    this.nodes.forEach(n =>\n      n._rect = {\n        y: n.y * h + top,\n        x: n.x * w + left,\n        w: n.w * w - left - right,\n        h: n.h * h - top - bottom\n      }\n    );\n    return this;\n  }\n\n  /** called to possibly swap between 2 nodes (same size or column, not locked, touching), returning true if successful */\n  public swap(a: GridStackNode, b: GridStackNode): boolean | undefined {\n    if (!b || b.locked || !a || a.locked) return false;\n\n    function _doSwap(): true { // assumes a is before b IFF they have different height (put after rather than exact swap)\n      let x = b.x, y = b.y;\n      b.x = a.x; b.y = a.y; // b -> a position\n      if (a.h != b.h) {\n        a.x = x; a.y = b.y + b.h; // a -> goes after b\n      } else if (a.w != b.w) {\n        a.x = b.x + b.w; a.y = y; // a -> goes after b\n      } else {\n        a.x = x; a.y = y; // a -> old b position\n      }\n      a._dirty = b._dirty = true;\n      return true;\n    }\n    let touching: boolean; // remember if we called it (vs undefined)\n\n    // same size and same row or column, and touching\n    if (a.w === b.w && a.h === b.h && (a.x === b.x || a.y === b.y) && (touching = Utils.isTouching(a, b)))\n      return _doSwap();\n    if (touching === false) return; // IFF ran test and fail, bail out\n\n    // check for taking same columns (but different height) and touching\n    if (a.w === b.w && a.x === b.x && (touching || (touching = Utils.isTouching(a, b)))) {\n      if (b.y < a.y) { let t = a; a = b; b = t; } // swap a <-> b vars so a is first\n      return _doSwap();\n    }\n    if (touching === false) return;\n\n    // check if taking same row (but different width) and touching\n    if (a.h === b.h && a.y === b.y && (touching || (touching = Utils.isTouching(a, b)))) {\n      if (b.x < a.x) { let t = a; a = b; b = t; } // swap a <-> b vars so a is first\n      return _doSwap();\n    }\n    return false;\n  }\n\n  public isAreaEmpty(x: number, y: number, w: number, h: number): boolean {\n    let nn: GridStackNode = {x: x || 0, y: y || 0, w: w || 1, h: h || 1};\n    return !this.collide(nn);\n  }\n\n  /** re-layout grid items to reclaim any empty space - optionally keeping the sort order exactly the same ('list' mode) vs truly finding an empty spaces */\n  public compact(layout: CompactOptions = 'compact', doSort = true): GridStackEngine {\n    if (this.nodes.length === 0) return this;\n    if (doSort) this.sortNodes();\n    const wasBatch = this.batchMode;\n    if (!wasBatch) this.batchUpdate();\n    const wasColumnResize = this._inColumnResize;\n    if (!wasColumnResize) this._inColumnResize = true; // faster addNode()\n    let copyNodes = this.nodes;\n    this.nodes = []; // pretend we have no nodes to conflict layout to start with...\n    copyNodes.forEach((n, index, list) => {\n      let after: GridStackNode;\n      if (!n.locked) {\n        n.autoPosition = true;\n        if (layout === 'list' && index) after = list[index - 1];\n      }\n      this.addNode(n, false, after); // 'false' for add event trigger\n    });\n    if (!wasColumnResize) delete this._inColumnResize;\n    if (!wasBatch) this.batchUpdate(false);\n    return this;\n  }\n\n  /** enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html) */\n  public set float(val: boolean) {\n    if (this._float === val) return;\n    this._float = val || false;\n    if (!val) {\n      this._packNodes()._notify();\n    }\n  }\n\n  /** float getter method */\n  public get float(): boolean { return this._float || false; }\n\n  /** sort the nodes array from first to last, or reverse. Called during collision/placement to force an order */\n  public sortNodes(dir: 1 | -1 = 1): GridStackEngine {\n    this.nodes = Utils.sort(this.nodes, dir);\n    return this;\n  }\n\n  /** @internal called to top gravity pack the items back OR revert back to original Y positions when floating */\n  protected _packNodes(): GridStackEngine {\n    if (this.batchMode) { return this; }\n    this.sortNodes(); // first to last\n\n    if (this.float) {\n      // restore original Y pos\n      this.nodes.forEach(n => {\n        if (n._updating || n._orig === undefined || n.y === n._orig.y) return;\n        let newY = n.y;\n        while (newY > n._orig.y) {\n          --newY;\n          let collide = this.collide(n, {x: n.x, y: newY, w: n.w, h: n.h});\n          if (!collide) {\n            n._dirty = true;\n            n.y = newY;\n          }\n        }\n      });\n    } else {\n      // top gravity pack\n      this.nodes.forEach((n, i) => {\n        if (n.locked) return;\n        while (n.y > 0) {\n          let newY = i === 0 ? 0 : n.y - 1;\n          let canBeMoved = i === 0 || !this.collide(n, {x: n.x, y: newY, w: n.w, h: n.h});\n          if (!canBeMoved) break;\n          // Note: must be dirty (from last position) for GridStack::OnChange CB to update positions\n          // and move items back. The user 'change' CB should detect changes from the original\n          // starting position instead.\n          n._dirty = (n.y !== newY);\n          n.y = newY;\n        }\n      });\n    }\n    return this;\n  }\n\n  /**\n   * given a random node, makes sure it's coordinates/values are valid in the current grid\n   * @param node to adjust\n   * @param resizing if out of bound, resize down or move into the grid to fit ?\n   */\n  public prepareNode(node: GridStackNode, resizing?: boolean): GridStackNode {\n    node._id = node._id ?? GridStackEngine._idSeq++;\n\n    // if we're missing position, have the grid position us automatically (before we set them to 0,0)\n    if (node.x === undefined || node.y === undefined || node.x === null || node.y === null) {\n      node.autoPosition = true;\n    }\n\n    // assign defaults for missing required fields\n    let defaults: GridStackNode = { x: 0, y: 0, w: 1, h: 1};\n    Utils.defaults(node, defaults);\n\n    if (!node.autoPosition) { delete node.autoPosition; }\n    if (!node.noResize) { delete node.noResize; }\n    if (!node.noMove) { delete node.noMove; }\n    Utils.sanitizeMinMax(node);\n\n    // check for NaN (in case messed up strings were passed. can't do parseInt() || defaults.x above as 0 is valid #)\n    if (typeof node.x == 'string') { node.x = Number(node.x); }\n    if (typeof node.y == 'string') { node.y = Number(node.y); }\n    if (typeof node.w == 'string') { node.w = Number(node.w); }\n    if (typeof node.h == 'string') { node.h = Number(node.h); }\n    if (isNaN(node.x)) { node.x = defaults.x; node.autoPosition = true; }\n    if (isNaN(node.y)) { node.y = defaults.y; node.autoPosition = true; }\n    if (isNaN(node.w)) { node.w = defaults.w; }\n    if (isNaN(node.h)) { node.h = defaults.h; }\n\n    this.nodeBoundFix(node, resizing);\n    return node;\n  }\n\n  /** part2 of preparing a node to fit inside our grid - checks for x,y,w from grid dimensions */\n  public nodeBoundFix(node: GridStackNode, resizing?: boolean): GridStackEngine {\n\n    let before = node._orig || Utils.copyPos({}, node);\n\n    if (node.maxW) { node.w = Math.min(node.w, node.maxW); }\n    if (node.maxH) { node.h = Math.min(node.h, node.maxH); }\n    if (node.minW && node.minW <= this.column) { node.w = Math.max(node.w, node.minW); }\n    if (node.minH) { node.h = Math.max(node.h, node.minH); }\n\n    // if user loaded a larger than allowed widget for current # of columns,\n    // remember it's position & width so we can restore back (1 -> 12 column) #1655 #1985\n    // IFF we're not in the middle of column resizing!\n    const saveOrig = (node.x || 0) + (node.w || 1) > this.column;\n    if (saveOrig && this.column < 12 && !this._inColumnResize && node._id && this.findCacheLayout(node, 12) === -1) {\n      let copy = {...node}; // need _id + positions\n      if (copy.autoPosition || copy.x === undefined) { delete copy.x; delete copy.y; }\n      else copy.x = Math.min(11, copy.x);\n      copy.w = Math.min(12, copy.w || 1);\n      this.cacheOneLayout(copy, 12);\n    }\n\n    if (node.w > this.column) {\n      node.w = this.column;\n    } else if (node.w < 1) {\n      node.w = 1;\n    }\n\n    if (this.maxRow && node.h > this.maxRow) {\n      node.h = this.maxRow;\n    } else if (node.h < 1) {\n      node.h = 1;\n    }\n\n    if (node.x < 0) {\n      node.x = 0;\n    }\n    if (node.y < 0) {\n      node.y = 0;\n    }\n\n    if (node.x + node.w > this.column) {\n      if (resizing) {\n        node.w = this.column - node.x;\n      } else {\n        node.x = this.column - node.w;\n      }\n    }\n    if (this.maxRow && node.y + node.h > this.maxRow) {\n      if (resizing) {\n        node.h = this.maxRow - node.y;\n      } else {\n        node.y = this.maxRow - node.h;\n      }\n    }\n\n    if (!Utils.samePos(node, before)) {\n      node._dirty = true;\n    }\n\n    return this;\n  }\n\n  /** returns a list of modified nodes from their original values */\n  public getDirtyNodes(verify?: boolean): GridStackNode[] {\n    // compare original x,y,w,h instead as _dirty can be a temporary state\n    if (verify) {\n      return this.nodes.filter(n => n._dirty && !Utils.samePos(n, n._orig));\n    }\n    return this.nodes.filter(n => n._dirty);\n  }\n\n  /** @internal call this to call onChange callback with dirty nodes so DOM can be updated */\n  protected _notify(removedNodes?: GridStackNode[]): GridStackEngine {\n    if (this.batchMode || !this.onChange) return this;\n    let dirtyNodes = (removedNodes || []).concat(this.getDirtyNodes());\n    this.onChange(dirtyNodes);\n    return this;\n  }\n\n  /** @internal remove dirty and last tried info */\n  public cleanNodes(): GridStackEngine {\n    if (this.batchMode) return this;\n    this.nodes.forEach(n => {\n      delete n._dirty;\n      delete n._lastTried;\n    });\n    return this;\n  }\n\n  /** @internal called to save initial position/size to track real dirty state.\n   * Note: should be called right after we call change event (so next API is can detect changes)\n   * as well as right before we start move/resize/enter (so we can restore items to prev values) */\n  public saveInitial(): GridStackEngine {\n    this.nodes.forEach(n => {\n      n._orig = Utils.copyPos({}, n);\n      delete n._dirty;\n    });\n    this._hasLocked = this.nodes.some(n => n.locked);\n    return this;\n  }\n\n  /** @internal restore all the nodes back to initial values (called when we leave) */\n  public restoreInitial(): GridStackEngine {\n    this.nodes.forEach(n => {\n      if (Utils.samePos(n, n._orig)) return;\n      Utils.copyPos(n, n._orig);\n      n._dirty = true;\n    });\n    this._notify();\n    return this;\n  }\n\n  /** find the first available empty spot for the given node width/height, updating the x,y attributes. return true if found.\n   * optionally you can pass your own existing node list and column count, otherwise defaults to that engine data.\n   * Optionally pass a widget to start search AFTER, meaning the order will remain the same but possibly have empty slots we skipped\n   */\n  public findEmptyPosition(node: GridStackNode, nodeList = this.nodes, column = this.column, after?: GridStackNode): boolean {\n    let start = after ? after.y * column + (after.x + after.w) : 0;\n    let found = false;\n    for (let i = start; !found; ++i) {\n      let x = i % column;\n      let y = Math.floor(i / column);\n      if (x + node.w > column) {\n        continue;\n      }\n      let box = {x, y, w: node.w, h: node.h};\n      if (!nodeList.find(n => Utils.isIntercepted(box, n))) {\n        if (node.x !== x || node.y !== y) node._dirty = true;\n        node.x = x;\n        node.y = y;\n        delete node.autoPosition;\n        found = true;\n      }\n    }\n    return found;\n  }\n\n  /** call to add the given node to our list, fixing collision and re-packing */\n  public addNode(node: GridStackNode, triggerAddEvent = false, after?: GridStackNode): GridStackNode {\n    let dup = this.nodes.find(n => n._id === node._id);\n    if (dup) return dup; // prevent inserting twice! return it instead.\n\n    // skip prepareNode if we're in middle of column resize (not new) but do check for bounds!\n    this._inColumnResize ? this.nodeBoundFix(node) : this.prepareNode(node);\n    delete node._temporaryRemoved;\n    delete node._removeDOM;\n\n    let skipCollision: boolean;\n    if (node.autoPosition && this.findEmptyPosition(node, this.nodes, this.column, after)) {\n      delete node.autoPosition; // found our slot\n      skipCollision = true;\n    }\n\n    this.nodes.push(node);\n    if (triggerAddEvent) { this.addedNodes.push(node); }\n\n    if (!skipCollision) this._fixCollisions(node);\n    if (!this.batchMode) { this._packNodes()._notify(); }\n    return node;\n  }\n\n  public removeNode(node: GridStackNode, removeDOM = true, triggerEvent = false): GridStackEngine {\n    if (!this.nodes.find(n => n._id === node._id)) {\n      // TEST console.log(`Error: GridStackEngine.removeNode() node._id=${node._id} not found!`)\n      return this;\n    }\n    if (triggerEvent) { // we wait until final drop to manually track removed items (rather than during drag)\n      this.removedNodes.push(node);\n    }\n    if (removeDOM) node._removeDOM = true; // let CB remove actual HTML (used to set _id to null, but then we loose layout info)\n    // don't use 'faster' .splice(findIndex(),1) in case node isn't in our list, or in multiple times.\n    this.nodes = this.nodes.filter(n => n._id !== node._id);\n    if (!node._isAboutToRemove) this._packNodes(); // if dragged out, no need to relayout as already done...\n    this._notify([node]);\n    return this;\n  }\n\n  public removeAll(removeDOM = true, triggerEvent = true): GridStackEngine {\n    delete this._layouts;\n    if (!this.nodes.length) return this;\n    removeDOM && this.nodes.forEach(n => n._removeDOM = true); // let CB remove actual HTML (used to set _id to null, but then we loose layout info)\n    const removedNodes = this.nodes;\n    this.removedNodes = triggerEvent ? removedNodes : [];\n    this.nodes = [];\n    return this._notify(removedNodes);\n  }\n\n  /** checks if item can be moved (layout constrain) vs moveNode(), returning true if was able to move.\n   * In more complicated cases (maxRow) it will attempt at moving the item and fixing\n   * others in a clone first, then apply those changes if still within specs. */\n  public moveNodeCheck(node: GridStackNode, o: GridStackMoveOpts): boolean {\n    // if (node.locked) return false;\n    if (!this.changedPosConstrain(node, o)) return false;\n    o.pack = true;\n\n    // simpler case: move item directly...\n    if (!this.maxRow) {\n      return this.moveNode(node, o);\n    }\n\n    // complex case: create a clone with NO maxRow (will check for out of bounds at the end)\n    let clonedNode: GridStackNode;\n    let clone = new GridStackEngine({\n      column: this.column,\n      float: this.float,\n      nodes: this.nodes.map(n => {\n        if (n._id === node._id) {\n          clonedNode = {...n};\n          return clonedNode;\n        }\n        return {...n};\n      })\n    });\n    if (!clonedNode) return false;\n\n    // check if we're covering 50% collision and could move, while still being under maxRow or at least not making it worse\n    // (case where widget was somehow added past our max #2449)\n    let canMove = clone.moveNode(clonedNode, o) && clone.getRow() <= Math.max(this.getRow(), this.maxRow);\n    // else check if we can force a swap (float=true, or different shapes) on non-resize\n    if (!canMove && !o.resizing && o.collide) {\n      let collide = o.collide.el.gridstackNode; // find the source node the clone collided with at 50%\n      if (this.swap(node, collide)) { // swaps and mark dirty\n        this._notify();\n        return true;\n      }\n    }\n    if (!canMove) return false;\n\n    // if clone was able to move, copy those mods over to us now instead of caller trying to do this all over!\n    // Note: we can't use the list directly as elements and other parts point to actual node, so copy content\n    clone.nodes.filter(n => n._dirty).forEach(c => {\n      let n = this.nodes.find(a => a._id === c._id);\n      if (!n) return;\n      Utils.copyPos(n, c);\n      n._dirty = true;\n    });\n    this._notify();\n    return true;\n  }\n\n  /** return true if can fit in grid height constrain only (always true if no maxRow) */\n  public willItFit(node: GridStackNode): boolean {\n    delete node._willFitPos;\n    if (!this.maxRow) return true;\n    // create a clone with NO maxRow and check if still within size\n    let clone = new GridStackEngine({\n      column: this.column,\n      float: this.float,\n      nodes: this.nodes.map(n => {return {...n}})\n    });\n    let n = {...node}; // clone node so we don't mod any settings on it but have full autoPosition and min/max as well! #1687\n    this.cleanupNode(n);\n    delete n.el; delete n._id; delete n.content; delete n.grid;\n    clone.addNode(n);\n    if (clone.getRow() <= this.maxRow) {\n      node._willFitPos = Utils.copyPos({}, n);\n      return true;\n    }\n    return false;\n  }\n\n  /** true if x,y or w,h are different after clamping to min/max */\n  public changedPosConstrain(node: GridStackNode, p: GridStackPosition): boolean {\n    // first make sure w,h are set for caller\n    p.w = p.w || node.w;\n    p.h = p.h || node.h;\n    if (node.x !== p.x || node.y !== p.y) return true;\n    // check constrained w,h\n    if (node.maxW) { p.w = Math.min(p.w, node.maxW); }\n    if (node.maxH) { p.h = Math.min(p.h, node.maxH); }\n    if (node.minW) { p.w = Math.max(p.w, node.minW); }\n    if (node.minH) { p.h = Math.max(p.h, node.minH); }\n    return (node.w !== p.w || node.h !== p.h);\n  }\n\n  /** return true if the passed in node was actually moved (checks for no-op and locked) */\n  public moveNode(node: GridStackNode, o: GridStackMoveOpts): boolean {\n    if (!node || /*node.locked ||*/ !o) return false;\n    let wasUndefinedPack: boolean;\n    if (o.pack === undefined && !this.batchMode) {\n      wasUndefinedPack = o.pack = true;\n    }\n\n    // constrain the passed in values and check if we're still changing our node\n    if (typeof o.x !== 'number') { o.x = node.x; }\n    if (typeof o.y !== 'number') { o.y = node.y; }\n    if (typeof o.w !== 'number') { o.w = node.w; }\n    if (typeof o.h !== 'number') { o.h = node.h; }\n    let resizing = (node.w !== o.w || node.h !== o.h);\n    let nn: GridStackNode = Utils.copyPos({}, node, true); // get min/max out first, then opt positions next\n    Utils.copyPos(nn, o);\n    this.nodeBoundFix(nn, resizing);\n    Utils.copyPos(o, nn);\n\n    if (!o.forceCollide && Utils.samePos(node, o)) return false;\n    let prevPos: GridStackPosition = Utils.copyPos({}, node);\n\n    // check if we will need to fix collision at our new location\n    let collides = this.collideAll(node, nn, o.skip);\n    let needToMove = true;\n    if (collides.length) {\n      let activeDrag = node._moving && !o.nested;\n      // check to make sure we actually collided over 50% surface area while dragging\n      let collide = activeDrag ? this.directionCollideCoverage(node, o, collides) : collides[0];\n      // if we're enabling creation of sub-grids on the fly, see if we're covering 80% of either one, if we didn't already do that\n      if (activeDrag && collide && node.grid?.opts?.subGridDynamic && !node.grid._isTemp) {\n        let over = Utils.areaIntercept(o.rect, collide._rect);\n        let a1 = Utils.area(o.rect);\n        let a2 = Utils.area(collide._rect);\n        let perc = over / (a1 < a2 ? a1 : a2);\n        if (perc > .8) {\n          collide.grid.makeSubGrid(collide.el, undefined, node);\n          collide = undefined;\n        }\n      }\n\n      if (collide) {\n        needToMove = !this._fixCollisions(node, nn, collide, o); // check if already moved...\n      } else {\n        needToMove = false; // we didn't cover >50% for a move, skip...\n        if (wasUndefinedPack) delete o.pack;\n      }\n    }\n\n    // now move (to the original ask vs the collision version which might differ) and repack things\n    if (needToMove) {\n      node._dirty = true;\n      Utils.copyPos(node, nn);\n    }\n    if (o.pack) {\n      this._packNodes()\n        ._notify();\n    }\n    return !Utils.samePos(node, prevPos); // pack might have moved things back\n  }\n\n  public getRow(): number {\n    return this.nodes.reduce((row, n) => Math.max(row, n.y + n.h), 0);\n  }\n\n  public beginUpdate(node: GridStackNode): GridStackEngine {\n    if (!node._updating) {\n      node._updating = true;\n      delete node._skipDown;\n      if (!this.batchMode) this.saveInitial();\n    }\n    return this;\n  }\n\n  public endUpdate(): GridStackEngine {\n    let n = this.nodes.find(n => n._updating);\n    if (n) {\n      delete n._updating;\n      delete n._skipDown;\n    }\n    return this;\n  }\n\n  /** saves a copy of the largest column layout (eg 12 even when rendering oneColumnMode) so we don't loose orig layout,\n   * returning a list of widgets for serialization */\n  public save(saveElement = true, saveCB?: SaveFcn): GridStackNode[] {\n    // use the highest layout for any saved info so we can have full detail on reload #1849\n    let len = this._layouts?.length;\n    let layout = len && this.column !== (len - 1) ? this._layouts[len - 1] : null;\n    let list: GridStackNode[] = [];\n    this.sortNodes();\n    this.nodes.forEach(n => {\n      let wl = layout?.find(l => l._id === n._id);\n      // use layout info fields instead if set\n      let w: GridStackNode = {...n, ...(wl || {})};\n      Utils.removeInternalForSave(w, !saveElement);\n      if (saveCB) saveCB(n, w);\n      list.push(w);\n    });\n    return list;\n  }\n\n  /** @internal called whenever a node is added or moved - updates the cached layouts */\n  public layoutsNodesChange(nodes: GridStackNode[]): GridStackEngine {\n    if (!this._layouts || this._inColumnResize) return this;\n    // remove smaller layouts - we will re-generate those on the fly... larger ones need to update\n    this._layouts.forEach((layout, column) => {\n      if (!layout || column === this.column) return this;\n      if (column < this.column) {\n        this._layouts[column] = undefined;\n      }\n      else {\n        // we save the original x,y,w (h isn't cached) to see what actually changed to propagate better.\n        // NOTE: we don't need to check against out of bound scaling/moving as that will be done when using those cache values. #1785\n        let ratio = column / this.column;\n        nodes.forEach(node => {\n          if (!node._orig) return; // didn't change (newly added ?)\n          let n = layout.find(l => l._id === node._id);\n          if (!n) return; // no cache for new nodes. Will use those values.\n          // Y changed, push down same amount\n          // TODO: detect doing item 'swaps' will help instead of move (especially in 1 column mode)\n          if (n.y >= 0 && node.y !== node._orig.y) {\n            n.y += (node.y - node._orig.y);\n          }\n          // X changed, scale from new position\n          if (node.x !== node._orig.x) {\n            n.x = Math.round(node.x * ratio);\n          }\n          // width changed, scale from new width\n          if (node.w !== node._orig.w) {\n            n.w = Math.round(node.w * ratio);\n          }\n          // ...height always carries over from cache\n        });\n      }\n    });\n    return this;\n  }\n\n  /**\n   * @internal Called to scale the widget width & position up/down based on the column change.\n   * Note we store previous layouts (especially original ones) to make it possible to go\n   * from say 12 -> 1 -> 12 and get back to where we were.\n   *\n   * @param prevColumn previous number of columns\n   * @param column  new column number\n   * @param layout specify the type of re-layout that will happen (position, size, etc...).\n   * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column\n   */\n  public columnChanged(prevColumn: number, column: number, layout: ColumnOptions = 'moveScale'): GridStackEngine {\n    if (!this.nodes.length || !column || prevColumn === column) return this;\n\n    // in this mode no layout is done whatsoever, up to the caller to handle it\n    if (layout === 'none') return this;\n\n    // simpler shortcuts layouts\n    const doCompact = layout === 'compact' || layout === 'list';\n    if (doCompact) {\n      this.sortNodes(1); // sort with original layout once and only once (new column will affect order otherwise)\n    }\n\n    // cache the current layout in case they want to go back (like 12 -> 1 -> 12) as it requires original data IFF we're sizing down (see below)\n    if (column < prevColumn) this.cacheLayout(this.nodes, prevColumn);\n    this.batchUpdate(); // do this EARLY as it will call saveInitial() so we can detect where we started for _dirty and collision\n    let newNodes: GridStackNode[] = [];\n    let nodes = doCompact ? this.nodes : Utils.sort(this.nodes, -1); // current column reverse sorting so we can insert last to front (limit collision)\n\n    // see if we have cached previous layout IFF we are going up in size (restore) otherwise always\n    // generate next size down from where we are (looks more natural as you gradually size down).\n    if (column > prevColumn && this._layouts) {\n      const cacheNodes = this._layouts[column] || [];\n      // ...if not, start with the largest layout (if not already there) as down-scaling is more accurate\n      // by pretending we came from that larger column by assigning those values as starting point\n      let lastIndex = this._layouts.length - 1;\n      if (!cacheNodes.length && prevColumn !== lastIndex && this._layouts[lastIndex]?.length) {\n        prevColumn = lastIndex;\n        this._layouts[lastIndex].forEach(cacheNode => {\n          let n = nodes.find(n => n._id === cacheNode._id);\n          if (n) {\n            // still current, use cache info positions\n            if (!doCompact && !cacheNode.autoPosition) {\n              n.x = cacheNode.x ?? n.x;\n              n.y = cacheNode.y ?? n.y;\n            }\n            n.w = cacheNode.w ?? n.w;\n            if (cacheNode.x == undefined || cacheNode.y === undefined) n.autoPosition = true;\n          }\n        });\n      }\n\n      // if we found cache re-use those nodes that are still current\n      cacheNodes.forEach(cacheNode => {\n        let j = nodes.findIndex(n => n._id === cacheNode._id);\n        if (j !== -1) {\n          const n = nodes[j];\n          // still current, use cache info positions\n          if (doCompact) {\n            n.w = cacheNode.w; // only w is used, and don't trim the list\n            return;\n          }\n          if (cacheNode.autoPosition || isNaN(cacheNode.x) || isNaN(cacheNode.y)) {\n            this.findEmptyPosition(cacheNode, newNodes);\n          }\n          if (!cacheNode.autoPosition) {\n            n.x = cacheNode.x ?? n.x;\n            n.y = cacheNode.y ?? n.y;\n            n.w = cacheNode.w ?? n.w;\n            newNodes.push(n);\n          }\n          nodes.splice(j, 1);\n        }\n      });\n    }\n\n    // much simpler layout that just compacts\n    if (doCompact) {\n      this.compact(layout, false);\n    } else {\n      // ...and add any extra non-cached ones\n      if (nodes.length) {\n        if (typeof layout === 'function') {\n          layout(column, prevColumn, newNodes, nodes);\n        } else {\n          let ratio = doCompact ? 1 : column / prevColumn;\n          let move = (layout === 'move' || layout === 'moveScale');\n          let scale = (layout === 'scale' || layout === 'moveScale');\n          nodes.forEach(node => {\n            // NOTE: x + w could be outside of the grid, but addNode() below will handle that\n            node.x = (column === 1 ? 0 : (move ? Math.round(node.x * ratio) : Math.min(node.x, column - 1)));\n            node.w = ((column === 1 || prevColumn === 1) ? 1 : scale ? (Math.round(node.w * ratio) || 1) : (Math.min(node.w, column)));\n            newNodes.push(node);\n          });\n          nodes = [];\n        }\n      }\n\n      // finally re-layout them in reverse order (to get correct placement)\n      newNodes = Utils.sort(newNodes, -1);\n      this._inColumnResize = true; // prevent cache update\n      this.nodes = []; // pretend we have no nodes to start with (add() will use same structures) to simplify layout\n      newNodes.forEach(node => {\n        this.addNode(node, false); // 'false' for add event trigger\n        delete node._orig; // make sure the commit doesn't try to restore things back to original\n      });\n    }\n\n    this.nodes.forEach(n => delete n._orig); // clear _orig before batch=false so it doesn't handle float=true restore\n    this.batchUpdate(false, !doCompact);\n    delete this._inColumnResize;\n    return this;\n  }\n\n  /**\n   * call to cache the given layout internally to the given location so we can restore back when column changes size\n   * @param nodes list of nodes\n   * @param column corresponding column index to save it under\n   * @param clear if true, will force other caches to be removed (default false)\n   */\n  public cacheLayout(nodes: GridStackNode[], column: number, clear = false): GridStackEngine {\n    let copy: GridStackNode[] = [];\n    nodes.forEach((n, i) => {\n      // make sure we have an id in case this is new layout, else re-use id already set\n      if (n._id === undefined) {\n        const existing = n.id ? this.nodes.find(n2 => n2.id === n.id) : undefined; // find existing node using users id\n        n._id = existing?._id ?? GridStackEngine._idSeq++;\n      }\n      copy[i] = {x: n.x, y: n.y, w: n.w, _id: n._id} // only thing we change is x,y,w and id to find it back\n    });\n    this._layouts = clear ? [] : this._layouts || []; // use array to find larger quick\n    this._layouts[column] = copy;\n    return this;\n  }\n\n  /**\n   * call to cache the given node layout internally to the given location so we can restore back when column changes size\n   * @param node single node to cache\n   * @param column corresponding column index to save it under\n   */\n  public cacheOneLayout(n: GridStackNode, column: number): GridStackEngine {\n    n._id = n._id ?? GridStackEngine._idSeq++;\n    let l: GridStackNode = {x: n.x, y: n.y, w: n.w, _id: n._id}\n    if (n.autoPosition || n.x === undefined) { delete l.x; delete l.y; if (n.autoPosition) l.autoPosition = true; }\n    this._layouts = this._layouts || [];\n    this._layouts[column] = this._layouts[column] || [];\n    let index = this.findCacheLayout(n, column);\n    if (index === -1)\n      this._layouts[column].push(l);\n    else\n      this._layouts[column][index] = l;\n    return this;\n  }\n\n  protected findCacheLayout(n: GridStackNode, column: number): number | undefined {\n    return this._layouts?.[column]?.findIndex(l => l._id === n._id) ?? -1;\n  }\n\n  public removeNodeFromLayoutCache(n: GridStackNode) {\n    if (!this._layouts) {\n      return;\n    }\n    for (let i = 0; i < this._layouts.length; i++) {\n      let index = this.findCacheLayout(n, i);\n      if (index !== -1) {\n        this._layouts[i].splice(index, 1);\n      }\n    }\n  }\n\n  /** called to remove all internal values but the _id */\n  public cleanupNode(node: GridStackNode): GridStackEngine {\n    for (let prop in node) {\n      if (prop[0] === '_' && prop !== '_id') delete node[prop];\n    }\n    return this;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}