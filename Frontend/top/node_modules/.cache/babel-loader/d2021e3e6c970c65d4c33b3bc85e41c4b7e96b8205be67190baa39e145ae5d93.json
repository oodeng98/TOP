{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*!\n * GridStack 10.3.1\n * https://gridstackjs.com/\n *\n * Copyright (c) 2021-2022 Alain Dumesny\n * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE\n */\nimport { GridStackEngine } from './gridstack-engine';\nimport { Utils, obsolete } from './utils';\nimport { gridDefaults, dragInDefaultOptions } from './types';\n/*\n * and include D&D by default\n * TODO: while we could generate a gridstack-static.js at smaller size - saves about 31k (41k -> 72k)\n * I don't know how to generate the DD only code at the remaining 31k to delay load as code depends on Gridstack.ts\n * also it caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\n */\nimport { DDGridStack } from './dd-gridstack';\nimport { isTouch } from './dd-touch';\nimport { DDManager } from './dd-manager';\nconst dd = new DDGridStack();\n// export all dependent file as well to make it easier for users to just import the main file\nexport * from './types';\nexport * from './utils';\nexport * from './gridstack-engine';\nexport * from './dd-gridstack';\n/**\n * Main gridstack class - you will need to call `GridStack.init()` first to initialize your grid.\n * Note: your grid elements MUST have the following classes for the CSS layout to work:\n * @example\n * <div class=\"grid-stack\">\n *   <div class=\"grid-stack-item\">\n *     <div class=\"grid-stack-item-content\">Item 1</div>\n *   </div>\n * </div>\n */\nclass GridStack {\n  /**\n   * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will\n   * simply return the existing instance (ignore any passed options). There is also an initAll() version that support\n   * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.\n   * @param options grid options (optional)\n   * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)\n   *\n   * @example\n   * let grid = GridStack.init();\n   *\n   * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later\n   * let grid = document.querySelector('.grid-stack').gridstack;\n   */\n  static init(options = {}, elOrString = '.grid-stack') {\n    if (typeof document === 'undefined') return null; // temp workaround SSR\n    let el = GridStack.getGridElement(elOrString);\n    if (!el) {\n      if (typeof elOrString === 'string') {\n        console.error('GridStack.initAll() no grid was found with selector \"' + elOrString + '\" - element missing or wrong selector ?' + '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\n      } else {\n        console.error('GridStack.init() no grid element was passed.');\n      }\n      return null;\n    }\n    if (!el.gridstack) {\n      el.gridstack = new GridStack(el, Utils.cloneDeep(options));\n    }\n    return el.gridstack;\n  }\n  /**\n   * Will initialize a list of elements (given a selector) and return an array of grids.\n   * @param options grid options (optional)\n   * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)\n   *\n   * @example\n   * let grids = GridStack.initAll();\n   * grids.forEach(...)\n   */\n  static initAll(options = {}, selector = '.grid-stack') {\n    let grids = [];\n    if (typeof document === 'undefined') return grids; // temp workaround SSR\n    GridStack.getGridElements(selector).forEach(el => {\n      if (!el.gridstack) {\n        el.gridstack = new GridStack(el, Utils.cloneDeep(options));\n      }\n      grids.push(el.gridstack);\n    });\n    if (grids.length === 0) {\n      console.error('GridStack.initAll() no grid was found with selector \"' + selector + '\" - element missing or wrong selector ?' + '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\n    }\n    return grids;\n  }\n  /**\n   * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then\n   * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from\n   * JSON serialized data, including options.\n   * @param parent HTML element parent to the grid\n   * @param opt grids options used to initialize the grid, and list of children\n   */\n  static addGrid(parent, opt = {}) {\n    if (!parent) return null;\n    let el = parent;\n    if (el.gridstack) {\n      // already a grid - set option and load data\n      const grid = el.gridstack;\n      if (opt) grid.opts = {\n        ...grid.opts,\n        ...opt\n      };\n      if (opt.children !== undefined) grid.load(opt.children);\n      return grid;\n    }\n    // create the grid element, but check if the passed 'parent' already has grid styling and should be used instead\n    const parentIsGrid = parent.classList.contains('grid-stack');\n    if (!parentIsGrid || GridStack.addRemoveCB) {\n      if (GridStack.addRemoveCB) {\n        el = GridStack.addRemoveCB(parent, opt, true, true);\n      } else {\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n        doc.body.innerHTML = `<div class=\"grid-stack ${opt.class || ''}\"></div>`;\n        el = doc.body.children[0];\n        parent.appendChild(el);\n      }\n    }\n    // create grid class and load any children\n    let grid = GridStack.init(opt, el);\n    return grid;\n  }\n  /** call this method to register your engine instead of the default one.\n   * See instead `GridStackOptions.engineClass` if you only need to\n   * replace just one instance.\n   */\n  static registerEngine(engineClass) {\n    GridStack.engineClass = engineClass;\n  }\n  /** @internal create placeholder DIV as needed */\n  get placeholder() {\n    if (!this._placeholder) {\n      let placeholderChild = document.createElement('div'); // child so padding match item-content\n      placeholderChild.className = 'placeholder-content';\n      if (this.opts.placeholderText) {\n        placeholderChild.innerHTML = this.opts.placeholderText;\n      }\n      this._placeholder = document.createElement('div');\n      this._placeholder.classList.add(this.opts.placeholderClass, gridDefaults.itemClass, this.opts.itemClass);\n      this.placeholder.appendChild(placeholderChild);\n    }\n    return this._placeholder;\n  }\n  /**\n   * Construct a grid item from the given element and options\n   * @param el the HTML element tied to this grid after it's been initialized\n   * @param opts grid options - public for classes to access, but use methods to modify!\n   */\n  constructor(el, opts = {}) {\n    this.el = el;\n    this.opts = opts;\n    /** @internal */\n    this._gsEventHandler = {};\n    /** @internal extra row added when dragging at the bottom of the grid */\n    this._extraDragRow = 0;\n    /** @internal meant to store the scale of the active grid */\n    this.dragTransform = {\n      xScale: 1,\n      yScale: 1,\n      xOffset: 0,\n      yOffset: 0\n    };\n    el.gridstack = this;\n    opts = opts || {}; // handles null/undefined/0\n    if (!el.classList.contains('grid-stack')) {\n      this.el.classList.add('grid-stack');\n    }\n    // if row property exists, replace minRow and maxRow instead\n    if (opts.row) {\n      opts.minRow = opts.maxRow = opts.row;\n      delete opts.row;\n    }\n    let rowAttr = Utils.toNumber(el.getAttribute('gs-row'));\n    // flag only valid in sub-grids (handled by parent, not here)\n    if (opts.column === 'auto') {\n      delete opts.column;\n    }\n    // save original setting so we can restore on save\n    if (opts.alwaysShowResizeHandle !== undefined) {\n      opts._alwaysShowResizeHandle = opts.alwaysShowResizeHandle;\n    }\n    let bk = opts.columnOpts?.breakpoints;\n    // LEGACY: oneColumnMode stuff changed in v10.x - check if user explicitly set something to convert over\n    const oldOpts = opts;\n    if (oldOpts.oneColumnModeDomSort) {\n      delete oldOpts.oneColumnModeDomSort;\n      console.log('warning: Gridstack oneColumnModeDomSort no longer supported. Use GridStackOptions.columnOpts instead.');\n    }\n    if (oldOpts.oneColumnSize || oldOpts.disableOneColumnMode === false) {\n      const oneSize = oldOpts.oneColumnSize || 768;\n      delete oldOpts.oneColumnSize;\n      delete oldOpts.disableOneColumnMode;\n      opts.columnOpts = opts.columnOpts || {};\n      bk = opts.columnOpts.breakpoints = opts.columnOpts.breakpoints || [];\n      let oneColumn = bk.find(b => b.c === 1);\n      if (!oneColumn) {\n        oneColumn = {\n          c: 1,\n          w: oneSize\n        };\n        bk.push(oneColumn, {\n          c: 12,\n          w: oneSize + 1\n        });\n      } else oneColumn.w = oneSize;\n    }\n    //...end LEGACY\n    // cleanup responsive opts (must have columnWidth | breakpoints) then sort breakpoints by size (so we can match during resize)\n    const resp = opts.columnOpts;\n    if (resp) {\n      if (!resp.columnWidth && !resp.breakpoints?.length) {\n        delete opts.columnOpts;\n        bk = undefined;\n      } else {\n        resp.columnMax = resp.columnMax || 12;\n      }\n    }\n    if (bk?.length > 1) bk.sort((a, b) => (b.w || 0) - (a.w || 0));\n    // elements DOM attributes override any passed options (like CSS style) - merge the two together\n    let defaults = {\n      ...Utils.cloneDeep(gridDefaults),\n      column: Utils.toNumber(el.getAttribute('gs-column')) || gridDefaults.column,\n      minRow: rowAttr ? rowAttr : Utils.toNumber(el.getAttribute('gs-min-row')) || gridDefaults.minRow,\n      maxRow: rowAttr ? rowAttr : Utils.toNumber(el.getAttribute('gs-max-row')) || gridDefaults.maxRow,\n      staticGrid: Utils.toBool(el.getAttribute('gs-static')) || gridDefaults.staticGrid,\n      draggable: {\n        handle: (opts.handleClass ? '.' + opts.handleClass : opts.handle ? opts.handle : '') || gridDefaults.draggable.handle\n      },\n      removableOptions: {\n        accept: opts.itemClass || gridDefaults.removableOptions.accept,\n        decline: gridDefaults.removableOptions.decline\n      }\n    };\n    if (el.getAttribute('gs-animate')) {\n      // default to true, but if set to false use that instead\n      defaults.animate = Utils.toBool(el.getAttribute('gs-animate'));\n    }\n    opts = Utils.defaults(opts, defaults);\n    this._initMargin(); // part of settings defaults...\n    // Now check if we're loading into 1 column mode FIRST so we don't do un-necessary work (like cellHeight = width / 12 then go 1 column)\n    this.checkDynamicColumn();\n    this.el.classList.add('gs-' + opts.column);\n    if (opts.rtl === 'auto') {\n      opts.rtl = el.style.direction === 'rtl';\n    }\n    if (opts.rtl) {\n      this.el.classList.add('grid-stack-rtl');\n    }\n    // check if we're been nested, and if so update our style and keep pointer around (used during save)\n    const grandParent = this.el.parentElement?.parentElement;\n    let parentGridItem = grandParent?.classList.contains(gridDefaults.itemClass) ? grandParent.gridstackNode : undefined;\n    if (parentGridItem) {\n      parentGridItem.subGrid = this;\n      this.parentGridItem = parentGridItem;\n      this.el.classList.add('grid-stack-nested');\n      parentGridItem.el.classList.add('grid-stack-sub-grid');\n    }\n    this._isAutoCellHeight = opts.cellHeight === 'auto';\n    if (this._isAutoCellHeight || opts.cellHeight === 'initial') {\n      // make the cell content square initially (will use resize/column event to keep it square)\n      this.cellHeight(undefined, false);\n    } else {\n      // append unit if any are set\n      if (typeof opts.cellHeight == 'number' && opts.cellHeightUnit && opts.cellHeightUnit !== gridDefaults.cellHeightUnit) {\n        opts.cellHeight = opts.cellHeight + opts.cellHeightUnit;\n        delete opts.cellHeightUnit;\n      }\n      this.cellHeight(opts.cellHeight, false);\n    }\n    // see if we need to adjust auto-hide\n    if (opts.alwaysShowResizeHandle === 'mobile') {\n      opts.alwaysShowResizeHandle = isTouch;\n    }\n    this._styleSheetClass = 'gs-id-' + GridStackEngine._idSeq++;\n    this.el.classList.add(this._styleSheetClass);\n    this._setStaticClass();\n    let engineClass = opts.engineClass || GridStack.engineClass || GridStackEngine;\n    this.engine = new engineClass({\n      column: this.getColumn(),\n      float: opts.float,\n      maxRow: opts.maxRow,\n      onChange: cbNodes => {\n        let maxH = 0;\n        this.engine.nodes.forEach(n => {\n          maxH = Math.max(maxH, n.y + n.h);\n        });\n        cbNodes.forEach(n => {\n          let el = n.el;\n          if (!el) return;\n          if (n._removeDOM) {\n            if (el) el.remove();\n            delete n._removeDOM;\n          } else {\n            this._writePosAttr(el, n);\n          }\n        });\n        this._updateStyles(false, maxH); // false = don't recreate, just append if need be\n      }\n    });\n    // create initial global styles BEFORE loading children so resizeToContent margin can be calculated correctly\n    this._updateStyles(false, 0);\n    if (opts.auto) {\n      this.batchUpdate(); // prevent in between re-layout #1535 TODO: this only set float=true, need to prevent collision check...\n      this.engine._loading = true; // loading collision check\n      this.getGridItems().forEach(el => this._prepareElement(el));\n      delete this.engine._loading;\n      this.batchUpdate(false);\n    }\n    // load any passed in children as well, which overrides any DOM layout done above\n    if (opts.children) {\n      const children = opts.children;\n      delete opts.children;\n      if (children.length) this.load(children); // don't load empty\n    }\n    // if (this.engine.nodes.length) this._updateStyles(); // update based on # of children. done in engine onChange CB\n    this.setAnimation();\n    // dynamic grids require pausing during drag to detect over to nest vs push\n    if (opts.subGridDynamic && !DDManager.pauseDrag) DDManager.pauseDrag = true;\n    if (opts.draggable?.pause !== undefined) DDManager.pauseDrag = opts.draggable.pause;\n    this._setupRemoveDrop();\n    this._setupAcceptWidget();\n    this._updateResizeEvent();\n  }\n  /**\n   * add a new widget and returns it.\n   *\n   * Widget will be always placed even if result height is more than actual grid height.\n   * You need to use `willItFit()` before calling addWidget for additional check.\n   * See also `makeWidget()`.\n   *\n   * @example\n   * let grid = GridStack.init();\n   * grid.addWidget({w: 3, content: 'hello'});\n   * grid.addWidget('<div class=\"grid-stack-item\"><div class=\"grid-stack-item-content\">hello</div></div>', {w: 3});\n   *\n   * @param el  GridStackWidget (which can have content string as well), html element, or string definition to add\n   * @param options widget position/size options (optional, and ignore if first param is already option) - see GridStackWidget\n   */\n  addWidget(els, options) {\n    function isGridStackWidget(w) {\n      return w.el !== undefined || w.x !== undefined || w.y !== undefined || w.w !== undefined || w.h !== undefined || w.content !== undefined ? true : false;\n    }\n    let el;\n    let node;\n    if (typeof els === 'string') {\n      let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n      doc.body.innerHTML = els;\n      el = doc.body.children[0];\n    } else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {\n      node = options = els;\n      if (node?.el) {\n        el = node.el; // re-use element stored in the node\n      } else if (GridStack.addRemoveCB) {\n        el = GridStack.addRemoveCB(this.el, options, true, false);\n      } else {\n        let content = options?.content || '';\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n        doc.body.innerHTML = `<div class=\"grid-stack-item ${this.opts.itemClass || ''}\"><div class=\"grid-stack-item-content\">${content}</div></div>`;\n        el = doc.body.children[0];\n      }\n    } else {\n      el = els;\n    }\n    if (!el) return;\n    // if the caller ended up initializing the widget in addRemoveCB, or we stared with one already, skip the rest\n    node = el.gridstackNode;\n    if (node && el.parentElement === this.el && this.engine.nodes.find(n => n._id === node._id)) return el;\n    // Tempting to initialize the passed in opt with default and valid values, but this break knockout demos\n    // as the actual value are filled in when _prepareElement() calls el.getAttribute('gs-xyz') before adding the node.\n    // So make sure we load any DOM attributes that are not specified in passed in options (which override)\n    let domAttr = this._readAttr(el);\n    options = Utils.cloneDeep(options) || {}; // make a copy before we modify in case caller re-uses it\n    Utils.defaults(options, domAttr);\n    node = this.engine.prepareNode(options);\n    this._writeAttr(el, options);\n    this.el.appendChild(el);\n    this.makeWidget(el, options);\n    return el;\n  }\n  /**\n   * Convert an existing gridItem element into a sub-grid with the given (optional) options, else inherit them\n   * from the parent's subGrid options.\n   * @param el gridItem element to convert\n   * @param ops (optional) sub-grid options, else default to node, then parent settings, else defaults\n   * @param nodeToAdd (optional) node to add to the newly created sub grid (used when dragging over existing regular item)\n   * @param saveContent if true (default) the html inside .grid-stack-content will be saved to child widget\n   * @returns newly created grid\n   */\n  makeSubGrid(el, ops, nodeToAdd, saveContent = true) {\n    let node = el.gridstackNode;\n    if (!node) {\n      node = this.makeWidget(el).gridstackNode;\n    }\n    if (node.subGrid?.el) return node.subGrid; // already done\n    // find the template subGrid stored on a parent as fallback...\n    let subGridTemplate; // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let grid = this;\n    while (grid && !subGridTemplate) {\n      subGridTemplate = grid.opts?.subGridOpts;\n      grid = grid.parentGridItem?.grid;\n    }\n    //... and set the create options\n    ops = Utils.cloneDeep({\n      ...(subGridTemplate || {}),\n      children: undefined,\n      ...(ops || node.subGridOpts || {})\n    });\n    node.subGridOpts = ops;\n    // if column special case it set, remember that flag and set default\n    let autoColumn;\n    if (ops.column === 'auto') {\n      autoColumn = true;\n      ops.column = Math.max(node.w || 1, nodeToAdd?.w || 1);\n      delete ops.columnOpts; // driven by parent\n    }\n    // if we're converting an existing full item, move over the content to be the first sub item in the new grid\n    let content = node.el.querySelector('.grid-stack-item-content');\n    let newItem;\n    let newItemOpt;\n    if (saveContent) {\n      this._removeDD(node.el); // remove D&D since it's set on content div\n      newItemOpt = {\n        ...node,\n        x: 0,\n        y: 0\n      };\n      Utils.removeInternalForSave(newItemOpt);\n      delete newItemOpt.subGridOpts;\n      if (node.content) {\n        newItemOpt.content = node.content;\n        delete node.content;\n      }\n      if (GridStack.addRemoveCB) {\n        newItem = GridStack.addRemoveCB(this.el, newItemOpt, true, false);\n      } else {\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n        doc.body.innerHTML = `<div class=\"grid-stack-item\"></div>`;\n        newItem = doc.body.children[0];\n        newItem.appendChild(content);\n        doc.body.innerHTML = `<div class=\"grid-stack-item-content\"></div>`;\n        content = doc.body.children[0];\n        node.el.appendChild(content);\n      }\n      this._prepareDragDropByNode(node); // ... and restore original D&D\n    }\n    // if we're adding an additional item, make the container large enough to have them both\n    if (nodeToAdd) {\n      let w = autoColumn ? ops.column : node.w;\n      let h = node.h + nodeToAdd.h;\n      let style = node.el.style;\n      style.transition = 'none'; // show up instantly so we don't see scrollbar with nodeToAdd\n      this.update(node.el, {\n        w,\n        h\n      });\n      setTimeout(() => style.transition = null); // recover animation\n    }\n    let subGrid = node.subGrid = GridStack.addGrid(content, ops);\n    if (nodeToAdd?._moving) subGrid._isTemp = true; // prevent re-nesting as we add over\n    if (autoColumn) subGrid._autoColumn = true;\n    // add the original content back as a child of hte newly created grid\n    if (saveContent) {\n      subGrid.addWidget(newItem, newItemOpt);\n    }\n    // now add any additional node\n    if (nodeToAdd) {\n      if (nodeToAdd._moving) {\n        // create an artificial event even for the just created grid to receive this item\n        window.setTimeout(() => Utils.simulateMouseEvent(nodeToAdd._event, 'mouseenter', subGrid.el), 0);\n      } else {\n        subGrid.addWidget(node.el, node);\n      }\n    }\n    return subGrid;\n  }\n  /**\n   * called when an item was converted into a nested grid to accommodate a dragged over item, but then item leaves - return back\n   * to the original grid-item. Also called to remove empty sub-grids when last item is dragged out (since re-creating is simple)\n   */\n  removeAsSubGrid(nodeThatRemoved) {\n    let pGrid = this.parentGridItem?.grid;\n    if (!pGrid) return;\n    pGrid.batchUpdate();\n    pGrid.removeWidget(this.parentGridItem.el, true, true);\n    this.engine.nodes.forEach(n => {\n      // migrate any children over and offsetting by our location\n      n.x += this.parentGridItem.x;\n      n.y += this.parentGridItem.y;\n      pGrid.addWidget(n.el, n);\n    });\n    pGrid.batchUpdate(false);\n    if (this.parentGridItem) delete this.parentGridItem.subGrid;\n    delete this.parentGridItem;\n    // create an artificial event for the original grid now that this one is gone (got a leave, but won't get enter)\n    if (nodeThatRemoved) {\n      window.setTimeout(() => Utils.simulateMouseEvent(nodeThatRemoved._event, 'mouseenter', pGrid.el), 0);\n    }\n  }\n  /**\n   * saves the current layout returning a list of widgets for serialization which might include any nested grids.\n   * @param saveContent if true (default) the latest html inside .grid-stack-content will be saved to GridStackWidget.content field, else it will\n   * be removed.\n   * @param saveGridOpt if true (default false), save the grid options itself, so you can call the new GridStack.addGrid()\n   * to recreate everything from scratch. GridStackOptions.children would then contain the widget list instead.\n   * @param saveCB callback for each node -> widget, so application can insert additional data to be saved into the widget data structure.\n   * @returns list of widgets or full grid option, including .children list of widgets\n   */\n  save(saveContent = true, saveGridOpt = false, saveCB = GridStack.saveCB) {\n    // return copied GridStackWidget (with optionally .el) we can modify at will...\n    let list = this.engine.save(saveContent, saveCB);\n    // check for HTML content and nested grids\n    list.forEach(n => {\n      if (saveContent && n.el && !n.subGrid && !saveCB) {\n        // sub-grid are saved differently, not plain content\n        let sub = n.el.querySelector('.grid-stack-item-content');\n        n.content = sub ? sub.innerHTML : undefined;\n        if (!n.content) delete n.content;\n      } else {\n        if (!saveContent && !saveCB) {\n          delete n.content;\n        }\n        // check for nested grid\n        if (n.subGrid?.el) {\n          const listOrOpt = n.subGrid.save(saveContent, saveGridOpt, saveCB);\n          n.subGridOpts = saveGridOpt ? listOrOpt : {\n            children: listOrOpt\n          };\n          delete n.subGrid;\n        }\n      }\n      delete n.el;\n    });\n    // check if save entire grid options (needed for recursive) + children...\n    if (saveGridOpt) {\n      let o = Utils.cloneDeep(this.opts);\n      // delete default values that will be recreated on launch\n      if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {\n        o.margin = o.marginTop;\n        delete o.marginTop;\n        delete o.marginRight;\n        delete o.marginBottom;\n        delete o.marginLeft;\n      }\n      if (o.rtl === (this.el.style.direction === 'rtl')) {\n        o.rtl = 'auto';\n      }\n      if (this._isAutoCellHeight) {\n        o.cellHeight = 'auto';\n      }\n      if (this._autoColumn) {\n        o.column = 'auto';\n      }\n      const origShow = o._alwaysShowResizeHandle;\n      delete o._alwaysShowResizeHandle;\n      if (origShow !== undefined) {\n        o.alwaysShowResizeHandle = origShow;\n      } else {\n        delete o.alwaysShowResizeHandle;\n      }\n      Utils.removeInternalAndSame(o, gridDefaults);\n      o.children = list;\n      return o;\n    }\n    return list;\n  }\n  /**\n   * load the widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.\n   *\n   * @param layout list of widgets definition to update/create\n   * @param addAndRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving\n   * the user control of insertion.\n   *\n   * @example\n   * see http://gridstackjs.com/demo/serialization.html\n   */\n  load(items, addRemove = GridStack.addRemoveCB || true) {\n    items = Utils.cloneDeep(items); // so we can mod\n    const column = this.getColumn();\n    // make sure size 1x1 (default) is present as it may need to override current sizes\n    items.forEach(n => {\n      n.w = n.w || 1;\n      n.h = n.h || 1;\n    });\n    // sort items. those without coord will be appended last\n    items = Utils.sort(items);\n    // if we're loading a layout into for example 1 column and items don't fit, make sure to save\n    // the original wanted layout so we can scale back up correctly #1471\n    let maxColumn = 0;\n    items.forEach(n => {\n      maxColumn = Math.max(maxColumn, (n.x || 0) + n.w);\n    });\n    if (maxColumn > column) {\n      this._ignoreLayoutsNodeChange = true; // skip layout update\n      this.engine.cacheLayout(items, maxColumn, true);\n    }\n    // if given a different callback, temporally set it as global option so creating will use it\n    const prevCB = GridStack.addRemoveCB;\n    if (typeof addRemove === 'function') GridStack.addRemoveCB = addRemove;\n    let removed = [];\n    this.batchUpdate();\n    // if we are loading from empty temporarily remove animation\n    const blank = !this.engine.nodes.length;\n    if (blank) this.setAnimation(false);\n    // see if any items are missing from new layout and need to be removed first\n    if (!blank && addRemove) {\n      let copyNodes = [...this.engine.nodes]; // don't loop through array you modify\n      copyNodes.forEach(n => {\n        if (!n.id) return;\n        let item = Utils.find(items, n.id);\n        if (!item) {\n          if (GridStack.addRemoveCB) GridStack.addRemoveCB(this.el, n, false, false);\n          removed.push(n); // batch keep track\n          this.removeWidget(n.el, true, false);\n        }\n      });\n    }\n    // now add/update the widgets - starting with removing items in the new layout we will reposition\n    // to reduce collision and add no-coord ones at next available spot\n    this.engine._loading = true; // help with collision\n    let updateNodes = [];\n    this.engine.nodes = this.engine.nodes.filter(n => {\n      if (Utils.find(items, n.id)) {\n        updateNodes.push(n);\n        return false;\n      } // remove if found from list\n      return true;\n    });\n    items.forEach(w => {\n      let item = Utils.find(updateNodes, w.id);\n      if (item) {\n        // if item sizes to content, re-use the exiting height so it's a better guess at the final size (same if width doesn't change)\n        if (Utils.shouldSizeToContent(item)) w.h = item.h;\n        // check if missing coord, in which case find next empty slot with new (or old if missing) sizes\n        this.engine.nodeBoundFix(w);\n        if (w.autoPosition || w.x === undefined || w.y === undefined) {\n          w.w = w.w || item.w;\n          w.h = w.h || item.h;\n          this.engine.findEmptyPosition(w);\n        }\n        // add back to current list BUT force a collision check if it 'appears' we didn't change to make sure we don't overlap others now\n        this.engine.nodes.push(item);\n        if (Utils.samePos(item, w)) {\n          this.moveNode(item, {\n            ...w,\n            forceCollide: true\n          });\n        }\n        this.update(item.el, w);\n        if (w.subGridOpts?.children) {\n          // update any sub grid as well\n          let sub = item.el.querySelector('.grid-stack');\n          if (sub && sub.gridstack) {\n            sub.gridstack.load(w.subGridOpts.children); // TODO: support updating grid options ?\n          }\n        }\n      } else if (addRemove) {\n        this.addWidget(w);\n      }\n    });\n    delete this.engine._loading; // done loading\n    this.engine.removedNodes = removed;\n    this.batchUpdate(false);\n    // after commit, clear that flag\n    delete this._ignoreLayoutsNodeChange;\n    prevCB ? GridStack.addRemoveCB = prevCB : delete GridStack.addRemoveCB;\n    // delay adding animation back\n    if (blank && this.opts?.animate) this.setAnimation(this.opts.animate, true);\n    return this;\n  }\n  /**\n   * use before calling a bunch of `addWidget()` to prevent un-necessary relayouts in between (more efficient)\n   * and get a single event callback. You will see no changes until `batchUpdate(false)` is called.\n   */\n  batchUpdate(flag = true) {\n    this.engine.batchUpdate(flag);\n    if (!flag) {\n      this._updateContainerHeight();\n      this._triggerRemoveEvent();\n      this._triggerAddEvent();\n      this._triggerChangeEvent();\n    }\n    return this;\n  }\n  /**\n   * Gets current cell height.\n   */\n  getCellHeight(forcePixel = false) {\n    if (this.opts.cellHeight && this.opts.cellHeight !== 'auto' && (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === 'px')) {\n      return this.opts.cellHeight;\n    }\n    // do rem/em/cm/mm to px conversion\n    if (this.opts.cellHeightUnit === 'rem') {\n      return this.opts.cellHeight * parseFloat(getComputedStyle(document.documentElement).fontSize);\n    }\n    if (this.opts.cellHeightUnit === 'em') {\n      return this.opts.cellHeight * parseFloat(getComputedStyle(this.el).fontSize);\n    }\n    if (this.opts.cellHeightUnit === 'cm') {\n      // 1cm = 96px/2.54. See https://www.w3.org/TR/css-values-3/#absolute-lengths\n      return this.opts.cellHeight * (96 / 2.54);\n    }\n    if (this.opts.cellHeightUnit === 'mm') {\n      return this.opts.cellHeight * (96 / 2.54) / 10;\n    }\n    // else get first cell height\n    let el = this.el.querySelector('.' + this.opts.itemClass);\n    if (el) {\n      let h = Utils.toNumber(el.getAttribute('gs-h')) || 1; // since we don't write 1 anymore\n      return Math.round(el.offsetHeight / h);\n    }\n    // else do entire grid and # of rows (but doesn't work if min-height is the actual constrain)\n    let rows = parseInt(this.el.getAttribute('gs-current-row'));\n    return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight;\n  }\n  /**\n   * Update current cell height - see `GridStackOptions.cellHeight` for format.\n   * This method rebuilds an internal CSS style sheet.\n   * Note: You can expect performance issues if call this method too often.\n   *\n   * @param val the cell height. If not passed (undefined), cells content will be made square (match width minus margin),\n   * if pass 0 the CSS will be generated by the application instead.\n   * @param update (Optional) if false, styles will not be updated\n   *\n   * @example\n   * grid.cellHeight(100); // same as 100px\n   * grid.cellHeight('70px');\n   * grid.cellHeight(grid.cellWidth() * 1.2);\n   */\n  cellHeight(val, update = true) {\n    // if not called internally, check if we're changing mode\n    if (update && val !== undefined) {\n      if (this._isAutoCellHeight !== (val === 'auto')) {\n        this._isAutoCellHeight = val === 'auto';\n        this._updateResizeEvent();\n      }\n    }\n    if (val === 'initial' || val === 'auto') {\n      val = undefined;\n    }\n    // make item content be square\n    if (val === undefined) {\n      let marginDiff = -this.opts.marginRight - this.opts.marginLeft + this.opts.marginTop + this.opts.marginBottom;\n      val = this.cellWidth() + marginDiff;\n    }\n    let data = Utils.parseHeight(val);\n    if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {\n      return this;\n    }\n    this.opts.cellHeightUnit = data.unit;\n    this.opts.cellHeight = data.h;\n    this.resizeToContentCheck();\n    if (update) {\n      this._updateStyles(true); // true = force re-create for current # of rows\n    }\n    return this;\n  }\n  /** Gets current cell width. */\n  cellWidth() {\n    return this._widthOrContainer() / this.getColumn();\n  }\n  /** return our expected width (or parent) , and optionally of window for dynamic column check */\n  _widthOrContainer(forBreakpoint = false) {\n    // use `offsetWidth` or `clientWidth` (no scrollbar) ?\n    // https://stackoverflow.com/questions/21064101/understanding-offsetwidth-clientwidth-scrollwidth-and-height-respectively\n    return forBreakpoint && this.opts.columnOpts?.breakpointForWindow ? window.innerWidth : this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth;\n  }\n  /** checks for dynamic column count for our current size, returning true if changed */\n  checkDynamicColumn() {\n    const resp = this.opts.columnOpts;\n    if (!resp || !resp.columnWidth && !resp.breakpoints?.length) return false;\n    const column = this.getColumn();\n    let newColumn = column;\n    const w = this._widthOrContainer(true);\n    if (resp.columnWidth) {\n      newColumn = Math.min(Math.round(w / resp.columnWidth) || 1, resp.columnMax);\n    } else {\n      // find the closest breakpoint (already sorted big to small) that matches\n      newColumn = resp.columnMax;\n      let i = 0;\n      while (i < resp.breakpoints.length && w <= resp.breakpoints[i].w) {\n        newColumn = resp.breakpoints[i++].c || column;\n      }\n    }\n    if (newColumn !== column) {\n      const bk = resp.breakpoints?.find(b => b.c === newColumn);\n      this.column(newColumn, bk?.layout || resp.layout);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * re-layout grid items to reclaim any empty space. Options are:\n   * 'list' keep the widget left->right order the same, even if that means leaving an empty slot if things don't fit\n   * 'compact' might re-order items to fill any empty space\n   *\n   * doSort - 'false' to let you do your own sorting ahead in case you need to control a different order. (default to sort)\n   */\n  compact(layout = 'compact', doSort = true) {\n    this.engine.compact(layout, doSort);\n    this._triggerChangeEvent();\n    return this;\n  }\n  /**\n   * set the number of columns in the grid. Will update existing widgets to conform to new number of columns,\n   * as well as cache the original layout so you can revert back to previous positions without loss.\n   * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11],\n   * else you will need to generate correct CSS (see https://github.com/gridstack/gridstack.js#change-grid-columns)\n   * @param column - Integer > 0 (default 12).\n   * @param layout specify the type of re-layout that will happen (position, size, etc...).\n   * Note: items will never be outside of the current column boundaries. default ('moveScale'). Ignored for 1 column\n   */\n  column(column, layout = 'moveScale') {\n    if (!column || column < 1 || this.opts.column === column) return this;\n    let oldColumn = this.getColumn();\n    this.opts.column = column;\n    if (!this.engine) return this; // called in constructor, noting else to do\n    this.engine.column = column;\n    this.el.classList.remove('gs-' + oldColumn);\n    this.el.classList.add('gs-' + column);\n    // update the items now, checking if we have a custom children layout\n    /*const newChildren = this.opts.columnOpts?.breakpoints?.find(r => r.c === column)?.children;\n    if (newChildren) this.load(newChildren);\n    else*/\n    this.engine.columnChanged(oldColumn, column, layout);\n    if (this._isAutoCellHeight) this.cellHeight();\n    this.resizeToContentCheck(true); // wait for width resizing\n    // and trigger our event last...\n    this._ignoreLayoutsNodeChange = true; // skip layout update\n    this._triggerChangeEvent();\n    delete this._ignoreLayoutsNodeChange;\n    return this;\n  }\n  /**\n   * get the number of columns in the grid (default 12)\n   */\n  getColumn() {\n    return this.opts.column;\n  }\n  /** returns an array of grid HTML elements (no placeholder) - used to iterate through our children in DOM order */\n  getGridItems() {\n    return Array.from(this.el.children).filter(el => el.matches('.' + this.opts.itemClass) && !el.matches('.' + this.opts.placeholderClass));\n  }\n  /**\n   * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.\n   * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).\n   */\n  destroy(removeDOM = true) {\n    if (!this.el) return; // prevent multiple calls\n    this.offAll();\n    this._updateResizeEvent(true);\n    this.setStatic(true, false); // permanently removes DD but don't set CSS class (we're going away)\n    this.setAnimation(false);\n    if (!removeDOM) {\n      this.removeAll(removeDOM);\n      this.el.classList.remove(this._styleSheetClass);\n      this.el.removeAttribute('gs-current-row');\n    } else {\n      this.el.parentNode.removeChild(this.el);\n    }\n    this._removeStylesheet();\n    if (this.parentGridItem) delete this.parentGridItem.subGrid;\n    delete this.parentGridItem;\n    delete this.opts;\n    delete this._placeholder;\n    delete this.engine;\n    delete this.el.gridstack; // remove circular dependency that would prevent a freeing\n    delete this.el;\n    return this;\n  }\n  /**\n   * enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html)\n   */\n  float(val) {\n    if (this.opts.float !== val) {\n      this.opts.float = this.engine.float = val;\n      this._triggerChangeEvent();\n    }\n    return this;\n  }\n  /**\n   * get the current float mode\n   */\n  getFloat() {\n    return this.engine.float;\n  }\n  /**\n   * Get the position of the cell under a pixel on screen.\n   * @param position the position of the pixel to resolve in\n   * absolute coordinates, as an object with top and left properties\n   * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).\n   * Useful when grid is within `position: relative` element\n   *\n   * Returns an object with properties `x` and `y` i.e. the column and row in the grid.\n   */\n  getCellFromPixel(position, useDocRelative = false) {\n    let box = this.el.getBoundingClientRect();\n    // console.log(`getBoundingClientRect left: ${box.left} top: ${box.top} w: ${box.w} h: ${box.h}`)\n    let containerPos;\n    if (useDocRelative) {\n      containerPos = {\n        top: box.top + document.documentElement.scrollTop,\n        left: box.left\n      };\n      // console.log(`getCellFromPixel scrollTop: ${document.documentElement.scrollTop}`)\n    } else {\n      containerPos = {\n        top: this.el.offsetTop,\n        left: this.el.offsetLeft\n      };\n      // console.log(`getCellFromPixel offsetTop: ${containerPos.left} offsetLeft: ${containerPos.top}`)\n    }\n    let relativeLeft = position.left - containerPos.left;\n    let relativeTop = position.top - containerPos.top;\n    let columnWidth = box.width / this.getColumn();\n    let rowHeight = box.height / parseInt(this.el.getAttribute('gs-current-row'));\n    return {\n      x: Math.floor(relativeLeft / columnWidth),\n      y: Math.floor(relativeTop / rowHeight)\n    };\n  }\n  /** returns the current number of rows, which will be at least `minRow` if set */\n  getRow() {\n    return Math.max(this.engine.getRow(), this.opts.minRow);\n  }\n  /**\n   * Checks if specified area is empty.\n   * @param x the position x.\n   * @param y the position y.\n   * @param w the width of to check\n   * @param h the height of to check\n   */\n  isAreaEmpty(x, y, w, h) {\n    return this.engine.isAreaEmpty(x, y, w, h);\n  }\n  /**\n   * If you add elements to your grid by hand (or have some framework creating DOM), you have to tell gridstack afterwards to make them widgets.\n   * If you want gridstack to add the elements for you, use `addWidget()` instead.\n   * Makes the given element a widget and returns it.\n   * @param els widget or single selector to convert.\n   * @param options widget definition to use instead of reading attributes or using default sizing values\n   *\n   * @example\n   * let grid = GridStack.init();\n   * grid.el.appendChild('<div id=\"1\" gs-w=\"3\"></div>');\n   * grid.el.appendChild('<div id=\"2\"></div>');\n   * grid.makeWidget('1');\n   * grid.makeWidget('2', {w:2, content: 'hello'});\n   */\n  makeWidget(els, options) {\n    let el = GridStack.getElement(els);\n    this._prepareElement(el, true, options);\n    const node = el.gridstackNode;\n    this._updateContainerHeight();\n    // see if there is a sub-grid to create\n    if (node.subGridOpts) {\n      this.makeSubGrid(el, node.subGridOpts, undefined, false); // node.subGrid will be used as option in method, no need to pass\n    }\n    // if we're adding an item into 1 column make sure\n    // we don't override the larger 12 column layout that was already saved. #1985\n    if (this.opts.column === 1) {\n      this._ignoreLayoutsNodeChange = true;\n    }\n    this._triggerAddEvent();\n    this._triggerChangeEvent();\n    delete this._ignoreLayoutsNodeChange;\n    return el;\n  }\n  on(name, callback) {\n    // check for array of names being passed instead\n    if (name.indexOf(' ') !== -1) {\n      let names = name.split(' ');\n      names.forEach(name => this.on(name, callback));\n      return this;\n    }\n    // native CustomEvent handlers - cash the generic handlers so we can easily remove\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\n      let noData = name === 'enable' || name === 'disable';\n      if (noData) {\n        this._gsEventHandler[name] = event => callback(event);\n      } else {\n        this._gsEventHandler[name] = event => callback(event, event.detail);\n      }\n      this.el.addEventListener(name, this._gsEventHandler[name]);\n    } else if (name === 'drag' || name === 'dragstart' || name === 'dragstop' || name === 'resizestart' || name === 'resize' || name === 'resizestop' || name === 'dropped' || name === 'resizecontent') {\n      // drag&drop stop events NEED to be call them AFTER we update node attributes so handle them ourself.\n      // do same for start event to make it easier...\n      this._gsEventHandler[name] = callback;\n    } else {\n      console.error('GridStack.on(' + name + ') event not supported');\n    }\n    return this;\n  }\n  /**\n   * unsubscribe from the 'on' event GridStackEvent\n   * @param name of the event (see possible values) or list of names space separated\n   */\n  off(name) {\n    // check for array of names being passed instead\n    if (name.indexOf(' ') !== -1) {\n      let names = name.split(' ');\n      names.forEach(name => this.off(name));\n      return this;\n    }\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\n      // remove native CustomEvent handlers\n      if (this._gsEventHandler[name]) {\n        this.el.removeEventListener(name, this._gsEventHandler[name]);\n      }\n    }\n    delete this._gsEventHandler[name];\n    return this;\n  }\n  /** remove all event handlers */\n  offAll() {\n    Object.keys(this._gsEventHandler).forEach(key => this.off(key));\n    return this;\n  }\n  /**\n   * Removes widget from the grid.\n   * @param el  widget or selector to modify\n   * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).\n   * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\n   */\n  removeWidget(els, removeDOM = true, triggerEvent = true) {\n    GridStack.getElements(els).forEach(el => {\n      if (el.parentElement && el.parentElement !== this.el) return; // not our child!\n      let node = el.gridstackNode;\n      // For Meteor support: https://github.com/gridstack/gridstack.js/pull/272\n      if (!node) {\n        node = this.engine.nodes.find(n => el === n.el);\n      }\n      if (!node) return;\n      if (removeDOM && GridStack.addRemoveCB) {\n        GridStack.addRemoveCB(this.el, node, false, false);\n      }\n      // remove our DOM data (circular link) and drag&drop permanently\n      delete el.gridstackNode;\n      this._removeDD(el);\n      this.engine.removeNode(node, removeDOM, triggerEvent);\n      if (removeDOM && el.parentElement) {\n        el.remove(); // in batch mode engine.removeNode doesn't call back to remove DOM\n      }\n    });\n    if (triggerEvent) {\n      this._triggerRemoveEvent();\n      this._triggerChangeEvent();\n    }\n    return this;\n  }\n  /**\n   * Removes all widgets from the grid.\n   * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).\n   * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\n   */\n  removeAll(removeDOM = true, triggerEvent = true) {\n    // always remove our DOM data (circular link) before list gets emptied and drag&drop permanently\n    this.engine.nodes.forEach(n => {\n      if (removeDOM && GridStack.addRemoveCB) {\n        GridStack.addRemoveCB(this.el, n, false, false);\n      }\n      delete n.el.gridstackNode;\n      if (!this.opts.staticGrid) this._removeDD(n.el);\n    });\n    this.engine.removeAll(removeDOM, triggerEvent);\n    if (triggerEvent) this._triggerRemoveEvent();\n    return this;\n  }\n  /**\n   * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.\n   * @param doAnimate if true the grid will animate.\n   * @param delay if true setting will be set on next event loop.\n   */\n  setAnimation(doAnimate = this.opts.animate, delay) {\n    if (delay) {\n      // delay, but check to make sure grid (opt) is still around\n      setTimeout(() => {\n        if (this.opts) this.setAnimation(doAnimate);\n      });\n    } else if (doAnimate) {\n      this.el.classList.add('grid-stack-animate');\n    } else {\n      this.el.classList.remove('grid-stack-animate');\n    }\n    return this;\n  }\n  /** @internal */\n  hasAnimationCSS() {\n    return this.el.classList.contains('grid-stack-animate');\n  }\n  /**\n   * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.\n   * Also toggle the grid-stack-static class.\n   * @param val if true the grid become static.\n   * @param updateClass true (default) if css class gets updated\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  setStatic(val, updateClass = true, recurse = true) {\n    if (!!this.opts.staticGrid === val) return this;\n    val ? this.opts.staticGrid = true : delete this.opts.staticGrid;\n    this._setupRemoveDrop();\n    this._setupAcceptWidget();\n    this.engine.nodes.forEach(n => {\n      this._prepareDragDropByNode(n); // either delete or init Drag&drop\n      if (n.subGrid && recurse) n.subGrid.setStatic(val, updateClass, recurse);\n    });\n    if (updateClass) {\n      this._setStaticClass();\n    }\n    return this;\n  }\n  /**\n   * Updates widget position/size and other info. Note: if you need to call this on all nodes, use load() instead which will update what changed.\n   * @param els  widget or selector of objects to modify (note: setting the same x,y for multiple items will be indeterministic and likely unwanted)\n   * @param opt new widget options (x,y,w,h, etc..). Only those set will be updated.\n   */\n  update(els, opt) {\n    // support legacy call for now ?\n    if (arguments.length > 2) {\n      console.warn('gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update(el, {x, w, content, ...})`. It will be removed soon');\n      // eslint-disable-next-line prefer-rest-params\n      let a = arguments,\n        i = 1;\n      opt = {\n        x: a[i++],\n        y: a[i++],\n        w: a[i++],\n        h: a[i++]\n      };\n      return this.update(els, opt);\n    }\n    GridStack.getElements(els).forEach(el => {\n      let n = el?.gridstackNode;\n      if (!n) return;\n      let w = Utils.cloneDeep(opt); // make a copy we can modify in case they re-use it or multiple items\n      this.engine.nodeBoundFix(w);\n      delete w.autoPosition;\n      delete w.id;\n      // move/resize widget if anything changed\n      let keys = ['x', 'y', 'w', 'h'];\n      let m;\n      if (keys.some(k => w[k] !== undefined && w[k] !== n[k])) {\n        m = {};\n        keys.forEach(k => {\n          m[k] = w[k] !== undefined ? w[k] : n[k];\n          delete w[k];\n        });\n      }\n      // for a move as well IFF there is any min/max fields set\n      if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {\n        m = {}; // will use node position but validate values\n      }\n      // check for content changing\n      if (w.content !== undefined) {\n        const itemContent = el.querySelector('.grid-stack-item-content');\n        if (itemContent && itemContent.innerHTML !== w.content) {\n          itemContent.innerHTML = w.content;\n          // restore any sub-grid back\n          if (n.subGrid?.el) {\n            itemContent.appendChild(n.subGrid.el);\n            if (!n.subGrid.opts.styleInHead) n.subGrid._updateStyles(true); // force create\n          }\n        }\n        delete w.content;\n      }\n      // any remaining fields are assigned, but check for dragging changes, resize constrain\n      let changed = false;\n      let ddChanged = false;\n      for (const key in w) {\n        if (key[0] !== '_' && n[key] !== w[key]) {\n          n[key] = w[key];\n          changed = true;\n          ddChanged = ddChanged || !this.opts.staticGrid && (key === 'noResize' || key === 'noMove' || key === 'locked');\n        }\n      }\n      Utils.sanitizeMinMax(n);\n      // finally move the widget and update attr\n      if (m) {\n        const widthChanged = m.w !== undefined && m.w !== n.w;\n        this.moveNode(n, m);\n        this.resizeToContentCheck(widthChanged, n); // wait for animation if we changed width\n        delete n._orig; // clear out original position now that we moved #2669\n      }\n      if (m || changed) {\n        this._writeAttr(el, n);\n      }\n      if (ddChanged) {\n        this._prepareDragDropByNode(n);\n      }\n    });\n    return this;\n  }\n  moveNode(n, m) {\n    const wasUpdating = n._updating;\n    if (!wasUpdating) this.engine.cleanNodes().beginUpdate(n);\n    this.engine.moveNode(n, m);\n    this._updateContainerHeight();\n    if (!wasUpdating) {\n      this._triggerChangeEvent();\n      this.engine.endUpdate();\n    }\n  }\n  /**\n   * Updates widget height to match the content height to avoid v-scrollbar or dead space.\n   * Note: this assumes only 1 child under resizeToContentParent='.grid-stack-item-content' (sized to gridItem minus padding) that is at the entire content size wanted.\n   * @param el grid item element\n   * @param useNodeH set to true if GridStackNode.h should be used instead of actual container height when we don't need to wait for animation to finish to get actual DOM heights\n   */\n  resizeToContent(el) {\n    if (!el) return;\n    el.classList.remove('size-to-content-max');\n    if (!el.clientHeight) return; // 0 when hidden, skip\n    const n = el.gridstackNode;\n    if (!n) return;\n    const grid = n.grid;\n    if (!grid || el.parentElement !== grid.el) return; // skip if we are not inside a grid\n    const cell = grid.getCellHeight(true);\n    if (!cell) return;\n    let height = n.h ? n.h * cell : el.clientHeight; // getBoundingClientRect().height seem to flicker back and forth\n    let item;\n    if (n.resizeToContentParent) item = el.querySelector(n.resizeToContentParent);\n    if (!item) item = el.querySelector(GridStack.resizeToContentParent);\n    if (!item) return;\n    const padding = el.clientHeight - item.clientHeight; // full - available height to our child (minus border, padding...)\n    const itemH = n.h ? n.h * cell - padding : item.clientHeight; // calculated to what cellHeight is or will become (rather than actual to prevent waiting for animation to finish)\n    let wantedH;\n    if (n.subGrid) {\n      // sub-grid - use their actual row count * their cell height\n      wantedH = n.subGrid.getRow() * n.subGrid.getCellHeight(true);\n    } else if (n.subGridOpts?.children?.length) {\n      // not sub-grid just yet (case above) wait until we do\n      return;\n    } else {\n      // NOTE: clientHeight & getBoundingClientRect() is undefined for text and other leaf nodes. use <div> container!\n      const child = item.firstElementChild;\n      if (!child) {\n        console.error(`Error: GridStack.resizeToContent() widget id:${n.id} '${GridStack.resizeToContentParent}'.firstElementChild is null, make sure to have a div like container. Skipping sizing.`);\n        return;\n      }\n      wantedH = child.getBoundingClientRect().height || itemH;\n    }\n    if (itemH === wantedH) return;\n    height += wantedH - itemH;\n    let h = Math.ceil(height / cell);\n    // check for min/max and special sizing\n    const softMax = Number.isInteger(n.sizeToContent) ? n.sizeToContent : 0;\n    if (softMax && h > softMax) {\n      h = softMax;\n      el.classList.add('size-to-content-max'); // get v-scroll back\n    }\n    if (n.minH && h < n.minH) h = n.minH;else if (n.maxH && h > n.maxH) h = n.maxH;\n    if (h !== n.h) {\n      grid._ignoreLayoutsNodeChange = true;\n      grid.moveNode(n, {\n        h\n      });\n      delete grid._ignoreLayoutsNodeChange;\n    }\n  }\n  /** call the user resize (so they can do extra work) else our build in version */\n  resizeToContentCBCheck(el) {\n    if (GridStack.resizeToContentCB) GridStack.resizeToContentCB(el);else this.resizeToContent(el);\n  }\n  /** rotate (by swapping w & h) the passed in node - called when user press 'r' during dragging\n   * @param els  widget or selector of objects to modify\n   * @param relative optional pixel coord relative to upper/left corner to rotate around (will keep that cell under cursor)\n   */\n  rotate(els, relative) {\n    GridStack.getElements(els).forEach(el => {\n      let n = el.gridstackNode;\n      if (!Utils.canBeRotated(n)) return;\n      const rot = {\n        w: n.h,\n        h: n.w,\n        minH: n.minW,\n        minW: n.minH,\n        maxH: n.maxW,\n        maxW: n.maxH\n      };\n      // if given an offset, adjust x/y by column/row bounds when user presses 'r' during dragging\n      if (relative) {\n        let pivotX = relative.left > 0 ? Math.floor(relative.left / this.cellWidth()) : 0;\n        let pivotY = relative.top > 0 ? Math.floor(relative.top / this.opts.cellHeight) : 0;\n        rot.x = n.x + pivotX - (n.h - (pivotY + 1));\n        rot.y = n.y + pivotY - pivotX;\n      }\n      Object.keys(rot).forEach(k => {\n        if (rot[k] === undefined) delete rot[k];\n      });\n      const _orig = n._orig;\n      this.update(el, rot);\n      n._orig = _orig; // restore as move() will delete it\n    });\n    return this;\n  }\n  /**\n   * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options (CSS string format of 1,2,4 values or single number).\n   * @param value margin value\n   */\n  margin(value) {\n    let isMultiValue = typeof value === 'string' && value.split(' ').length > 1;\n    // check if we can skip re-creating our CSS file... won't check if multi values (too much hassle)\n    if (!isMultiValue) {\n      let data = Utils.parseHeight(value);\n      if (this.opts.marginUnit === data.unit && this.opts.margin === data.h) return;\n    }\n    // re-use existing margin handling\n    this.opts.margin = value;\n    this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = undefined;\n    this._initMargin();\n    this._updateStyles(true); // true = force re-create\n    return this;\n  }\n  /** returns current margin number value (undefined if 4 sides don't match) */\n  getMargin() {\n    return this.opts.margin;\n  }\n  /**\n   * Returns true if the height of the grid will be less than the vertical\n   * constraint. Always returns true if grid doesn't have height constraint.\n   * @param node contains x,y,w,h,auto-position options\n   *\n   * @example\n   * if (grid.willItFit(newWidget)) {\n   *   grid.addWidget(newWidget);\n   * } else {\n   *   alert('Not enough free space to place the widget');\n   * }\n   */\n  willItFit(node) {\n    // support legacy call for now\n    if (arguments.length > 1) {\n      console.warn('gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon');\n      // eslint-disable-next-line prefer-rest-params\n      let a = arguments,\n        i = 0,\n        w = {\n          x: a[i++],\n          y: a[i++],\n          w: a[i++],\n          h: a[i++],\n          autoPosition: a[i++]\n        };\n      return this.willItFit(w);\n    }\n    return this.engine.willItFit(node);\n  }\n  /** @internal */\n  _triggerChangeEvent() {\n    if (this.engine.batchMode) return this;\n    let elements = this.engine.getDirtyNodes(true); // verify they really changed\n    if (elements && elements.length) {\n      if (!this._ignoreLayoutsNodeChange) {\n        this.engine.layoutsNodesChange(elements);\n      }\n      this._triggerEvent('change', elements);\n    }\n    this.engine.saveInitial(); // we called, now reset initial values & dirty flags\n    return this;\n  }\n  /** @internal */\n  _triggerAddEvent() {\n    if (this.engine.batchMode) return this;\n    if (this.engine.addedNodes?.length) {\n      if (!this._ignoreLayoutsNodeChange) {\n        this.engine.layoutsNodesChange(this.engine.addedNodes);\n      }\n      // prevent added nodes from also triggering 'change' event (which is called next)\n      this.engine.addedNodes.forEach(n => {\n        delete n._dirty;\n      });\n      const addedNodes = [...this.engine.addedNodes];\n      this.engine.addedNodes = [];\n      this._triggerEvent('added', addedNodes);\n    }\n    return this;\n  }\n  /** @internal */\n  _triggerRemoveEvent() {\n    if (this.engine.batchMode) return this;\n    if (this.engine.removedNodes?.length) {\n      const removedNodes = [...this.engine.removedNodes];\n      this.engine.removedNodes = [];\n      this._triggerEvent('removed', removedNodes);\n    }\n    return this;\n  }\n  /** @internal */\n  _triggerEvent(type, data) {\n    let event = data ? new CustomEvent(type, {\n      bubbles: false,\n      detail: data\n    }) : new Event(type);\n    this.el.dispatchEvent(event);\n    return this;\n  }\n  /** @internal called to delete the current dynamic style sheet used for our layout */\n  _removeStylesheet() {\n    if (this._styles) {\n      const styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode;\n      Utils.removeStylesheet(this._styleSheetClass, styleLocation);\n      delete this._styles;\n    }\n    return this;\n  }\n  /** @internal updated/create the CSS styles for row based layout and initial margin setting */\n  _updateStyles(forceUpdate = false, maxH) {\n    // call to delete existing one if we change cellHeight / margin\n    if (forceUpdate) {\n      this._removeStylesheet();\n    }\n    if (maxH === undefined) maxH = this.getRow();\n    this._updateContainerHeight();\n    // if user is telling us they will handle the CSS themselves by setting heights to 0. Do we need this opts really ??\n    if (this.opts.cellHeight === 0) {\n      return this;\n    }\n    let cellHeight = this.opts.cellHeight;\n    let cellHeightUnit = this.opts.cellHeightUnit;\n    let prefix = `.${this._styleSheetClass} > .${this.opts.itemClass}`;\n    // create one as needed\n    if (!this._styles) {\n      // insert style to parent (instead of 'head' by default) to support WebComponent\n      const styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode;\n      this._styles = Utils.createStylesheet(this._styleSheetClass, styleLocation, {\n        nonce: this.opts.nonce\n      });\n      if (!this._styles) return this;\n      this._styles._max = 0;\n      // these are done once only\n      Utils.addCSSRule(this._styles, prefix, `height: ${cellHeight}${cellHeightUnit}`);\n      // content margins\n      let top = this.opts.marginTop + this.opts.marginUnit;\n      let bottom = this.opts.marginBottom + this.opts.marginUnit;\n      let right = this.opts.marginRight + this.opts.marginUnit;\n      let left = this.opts.marginLeft + this.opts.marginUnit;\n      let content = `${prefix} > .grid-stack-item-content`;\n      let placeholder = `.${this._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`;\n      Utils.addCSSRule(this._styles, content, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\n      Utils.addCSSRule(this._styles, placeholder, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\n      // resize handles offset (to match margin)\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-n`, `top: ${top};`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-s`, `bottom: ${bottom}`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-ne`, `right: ${right}`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-e`, `right: ${right}`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-se`, `right: ${right}; bottom: ${bottom}`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-nw`, `left: ${left}`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-w`, `left: ${left}`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-sw`, `left: ${left}; bottom: ${bottom}`);\n    }\n    // now update the height specific fields\n    maxH = maxH || this._styles._max;\n    if (maxH > this._styles._max) {\n      let getHeight = rows => cellHeight * rows + cellHeightUnit;\n      for (let i = this._styles._max + 1; i <= maxH; i++) {\n        // start at 1\n        Utils.addCSSRule(this._styles, `${prefix}[gs-y=\"${i}\"]`, `top: ${getHeight(i)}`);\n        Utils.addCSSRule(this._styles, `${prefix}[gs-h=\"${i + 1}\"]`, `height: ${getHeight(i + 1)}`); // start at 2\n      }\n      this._styles._max = maxH;\n    }\n    return this;\n  }\n  /** @internal */\n  _updateContainerHeight() {\n    if (!this.engine || this.engine.batchMode) return this;\n    const parent = this.parentGridItem;\n    let row = this.getRow() + this._extraDragRow; // this checks for minRow already\n    const cellHeight = this.opts.cellHeight;\n    const unit = this.opts.cellHeightUnit;\n    if (!cellHeight) return this;\n    // check for css min height (non nested grid). TODO: support mismatch, say: min % while unit is px.\n    if (!parent) {\n      const cssMinHeight = Utils.parseHeight(getComputedStyle(this.el)['minHeight']);\n      if (cssMinHeight.h > 0 && cssMinHeight.unit === unit) {\n        const minRow = Math.floor(cssMinHeight.h / cellHeight);\n        if (row < minRow) {\n          row = minRow;\n        }\n      }\n    }\n    this.el.setAttribute('gs-current-row', String(row));\n    this.el.style.removeProperty('min-height');\n    this.el.style.removeProperty('height');\n    if (row) {\n      // nested grids have 'insert:0' to fill the space of parent by default, but we may be taller so use min-height for possible scrollbars\n      this.el.style[parent ? 'minHeight' : 'height'] = row * cellHeight + unit;\n    }\n    // if we're a nested grid inside an sizeToContent item, tell it to resize itself too\n    if (parent && !parent.grid.engine.batchMode && Utils.shouldSizeToContent(parent)) {\n      parent.grid.resizeToContentCBCheck(parent.el);\n    }\n    return this;\n  }\n  /** @internal */\n  _prepareElement(el, triggerAddEvent = false, node) {\n    node = node || this._readAttr(el);\n    el.gridstackNode = node;\n    node.el = el;\n    node.grid = this;\n    node = this.engine.addNode(node, triggerAddEvent);\n    // write the dom sizes and class\n    this._writeAttr(el, node);\n    el.classList.add(gridDefaults.itemClass, this.opts.itemClass);\n    const sizeToContent = Utils.shouldSizeToContent(node);\n    sizeToContent ? el.classList.add('size-to-content') : el.classList.remove('size-to-content');\n    if (sizeToContent) this.resizeToContentCheck(false, node);\n    this._prepareDragDropByNode(node);\n    return this;\n  }\n  /** @internal call to write position x,y,w,h attributes back to element */\n  _writePosAttr(el, n) {\n    if (n.x !== undefined && n.x !== null) {\n      el.setAttribute('gs-x', String(n.x));\n    }\n    if (n.y !== undefined && n.y !== null) {\n      el.setAttribute('gs-y', String(n.y));\n    }\n    n.w > 1 ? el.setAttribute('gs-w', String(n.w)) : el.removeAttribute('gs-w');\n    n.h > 1 ? el.setAttribute('gs-h', String(n.h)) : el.removeAttribute('gs-h');\n    return this;\n  }\n  /** @internal call to write any default attributes back to element */\n  _writeAttr(el, node) {\n    if (!node) return this;\n    this._writePosAttr(el, node);\n    let attrs /*: GridStackWidget but strings */ = {\n      autoPosition: 'gs-auto-position',\n      noResize: 'gs-no-resize',\n      noMove: 'gs-no-move',\n      locked: 'gs-locked',\n      id: 'gs-id'\n    };\n    for (const key in attrs) {\n      if (node[key]) {\n        // 0 is valid for x,y only but done above already and not in list anyway\n        el.setAttribute(attrs[key], String(node[key]));\n      } else {\n        el.removeAttribute(attrs[key]);\n      }\n    }\n    return this;\n  }\n  /** @internal call to read any default attributes from element */\n  _readAttr(el, clearDefaultAttr = true) {\n    let n = {};\n    n.x = Utils.toNumber(el.getAttribute('gs-x'));\n    n.y = Utils.toNumber(el.getAttribute('gs-y'));\n    n.w = Utils.toNumber(el.getAttribute('gs-w'));\n    n.h = Utils.toNumber(el.getAttribute('gs-h'));\n    n.autoPosition = Utils.toBool(el.getAttribute('gs-auto-position'));\n    n.noResize = Utils.toBool(el.getAttribute('gs-no-resize'));\n    n.noMove = Utils.toBool(el.getAttribute('gs-no-move'));\n    n.locked = Utils.toBool(el.getAttribute('gs-locked'));\n    n.id = el.getAttribute('gs-id');\n    // read but never written out\n    n.maxW = Utils.toNumber(el.getAttribute('gs-max-w'));\n    n.minW = Utils.toNumber(el.getAttribute('gs-min-w'));\n    n.maxH = Utils.toNumber(el.getAttribute('gs-max-h'));\n    n.minH = Utils.toNumber(el.getAttribute('gs-min-h'));\n    // v8.x optimization to reduce un-needed attr that don't render or are default CSS\n    if (clearDefaultAttr) {\n      if (n.w === 1) el.removeAttribute('gs-w');\n      if (n.h === 1) el.removeAttribute('gs-h');\n      if (n.maxW) el.removeAttribute('gs-max-w');\n      if (n.minW) el.removeAttribute('gs-min-w');\n      if (n.maxH) el.removeAttribute('gs-max-h');\n      if (n.minH) el.removeAttribute('gs-min-h');\n    }\n    // remove any key not found (null or false which is default)\n    for (const key in n) {\n      if (!n.hasOwnProperty(key)) return;\n      if (!n[key] && n[key] !== 0) {\n        // 0 can be valid value (x,y only really)\n        delete n[key];\n      }\n    }\n    return n;\n  }\n  /** @internal */\n  _setStaticClass() {\n    let classes = ['grid-stack-static'];\n    if (this.opts.staticGrid) {\n      this.el.classList.add(...classes);\n      this.el.setAttribute('gs-static', 'true');\n    } else {\n      this.el.classList.remove(...classes);\n      this.el.removeAttribute('gs-static');\n    }\n    return this;\n  }\n  /**\n   * called when we are being resized - check if the one Column Mode needs to be turned on/off\n   * and remember the prev columns we used, or get our count from parent, as well as check for cellHeight==='auto' (square)\n   * or `sizeToContent` gridItem options.\n   */\n  onResize() {\n    if (!this.el?.clientWidth) return; // return if we're gone or no size yet (will get called again)\n    if (this.prevWidth === this.el.clientWidth) return; // no-op\n    this.prevWidth = this.el.clientWidth;\n    // console.log('onResize ', this.el.clientWidth);\n    this.batchUpdate();\n    // see if we're nested and take our column count from our parent....\n    let columnChanged = false;\n    if (this._autoColumn && this.parentGridItem) {\n      if (this.opts.column !== this.parentGridItem.w) {\n        this.column(this.parentGridItem.w, 'none');\n        columnChanged = true;\n      }\n    } else {\n      // else check for dynamic column\n      columnChanged = this.checkDynamicColumn();\n    }\n    // make the cells content square again\n    if (this._isAutoCellHeight) this.cellHeight();\n    // update any nested grids, or items size\n    this.engine.nodes.forEach(n => {\n      if (n.subGrid) n.subGrid.onResize();\n    });\n    if (!this._skipInitialResize) this.resizeToContentCheck(columnChanged); // wait for anim of column changed (DOM reflow before we can size correctly)\n    delete this._skipInitialResize;\n    this.batchUpdate(false);\n    return this;\n  }\n  /** resizes content for given node (or all) if shouldSizeToContent() is true */\n  resizeToContentCheck(delay = false, n = undefined) {\n    if (!this.engine) return; // we've been deleted in between!\n    // update any gridItem height with sizeToContent, but wait for DOM $animation_speed to settle if we changed column count\n    // TODO: is there a way to know what the final (post animation) size of the content will be so we can animate the column width and height together rather than sequentially ?\n    if (delay && this.hasAnimationCSS()) return setTimeout(() => this.resizeToContentCheck(false, n), 300 + 10);\n    if (n) {\n      if (Utils.shouldSizeToContent(n)) this.resizeToContentCBCheck(n.el);\n    } else if (this.engine.nodes.some(n => Utils.shouldSizeToContent(n))) {\n      const nodes = [...this.engine.nodes]; // in case order changes while resizing one\n      this.batchUpdate();\n      nodes.forEach(n => {\n        if (Utils.shouldSizeToContent(n)) this.resizeToContentCBCheck(n.el);\n      });\n      this.batchUpdate(false);\n    }\n    // call this regardless of shouldSizeToContent because widget might need to stretch to take available space after a resize\n    if (this._gsEventHandler['resizecontent']) this._gsEventHandler['resizecontent'](null, n ? [n] : this.engine.nodes);\n  }\n  /** add or remove the grid element size event handler */\n  _updateResizeEvent(forceRemove = false) {\n    // only add event if we're not nested (parent will call us) and we're auto sizing cells or supporting dynamic column (i.e. doing work)\n    // or supporting new sizeToContent option.\n    const trackSize = !this.parentGridItem && (this._isAutoCellHeight || this.opts.sizeToContent || this.opts.columnOpts || this.engine.nodes.find(n => n.sizeToContent));\n    if (!forceRemove && trackSize && !this.resizeObserver) {\n      this._sizeThrottle = Utils.throttle(() => this.onResize(), this.opts.cellHeightThrottle);\n      this.resizeObserver = new ResizeObserver(() => this._sizeThrottle());\n      this.resizeObserver.observe(this.el);\n      this._skipInitialResize = true; // makeWidget will originally have called on startup\n    } else if ((forceRemove || !trackSize) && this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      delete this.resizeObserver;\n      delete this._sizeThrottle;\n    }\n    return this;\n  }\n  /** @internal convert a potential selector into actual element */\n  static getElement(els = '.grid-stack-item') {\n    return Utils.getElement(els);\n  }\n  /** @internal */\n  static getElements(els = '.grid-stack-item') {\n    return Utils.getElements(els);\n  }\n  /** @internal */\n  static getGridElement(els) {\n    return GridStack.getElement(els);\n  }\n  /** @internal */\n  static getGridElements(els) {\n    return Utils.getElements(els);\n  }\n  /** @internal initialize margin top/bottom/left/right and units */\n  _initMargin() {\n    let data;\n    let margin = 0;\n    // support passing multiple values like CSS (ex: '5px 10px 0 20px')\n    let margins = [];\n    if (typeof this.opts.margin === 'string') {\n      margins = this.opts.margin.split(' ');\n    }\n    if (margins.length === 2) {\n      // top/bot, left/right like CSS\n      this.opts.marginTop = this.opts.marginBottom = margins[0];\n      this.opts.marginLeft = this.opts.marginRight = margins[1];\n    } else if (margins.length === 4) {\n      // Clockwise like CSS\n      this.opts.marginTop = margins[0];\n      this.opts.marginRight = margins[1];\n      this.opts.marginBottom = margins[2];\n      this.opts.marginLeft = margins[3];\n    } else {\n      data = Utils.parseHeight(this.opts.margin);\n      this.opts.marginUnit = data.unit;\n      margin = this.opts.margin = data.h;\n    }\n    // see if top/bottom/left/right need to be set as well\n    if (this.opts.marginTop === undefined) {\n      this.opts.marginTop = margin;\n    } else {\n      data = Utils.parseHeight(this.opts.marginTop);\n      this.opts.marginTop = data.h;\n      delete this.opts.margin;\n    }\n    if (this.opts.marginBottom === undefined) {\n      this.opts.marginBottom = margin;\n    } else {\n      data = Utils.parseHeight(this.opts.marginBottom);\n      this.opts.marginBottom = data.h;\n      delete this.opts.margin;\n    }\n    if (this.opts.marginRight === undefined) {\n      this.opts.marginRight = margin;\n    } else {\n      data = Utils.parseHeight(this.opts.marginRight);\n      this.opts.marginRight = data.h;\n      delete this.opts.margin;\n    }\n    if (this.opts.marginLeft === undefined) {\n      this.opts.marginLeft = margin;\n    } else {\n      data = Utils.parseHeight(this.opts.marginLeft);\n      this.opts.marginLeft = data.h;\n      delete this.opts.margin;\n    }\n    this.opts.marginUnit = data.unit; // in case side were spelled out, use those units instead...\n    if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {\n      this.opts.margin = this.opts.marginTop; // makes it easier to check for no-ops in setMargin()\n    }\n    return this;\n  }\n  /* ===========================================================================================\n   * drag&drop methods that used to be stubbed out and implemented in dd-gridstack.ts\n   * but caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\n   * ===========================================================================================\n   */\n  /** get the global (but static to this code) DD implementation */\n  static getDD() {\n    return dd;\n  }\n  /**\n   * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.\n   * Called during GridStack.init() as options, but can also be called directly (last param are used) in case the toolbar\n   * is dynamically create and needs to be set later.\n   * @param dragIn string selector (ex: '.sidebar .grid-stack-item') or list of dom elements\n   * @param dragInOptions options - see DDDragInOpt. (default: {handle: '.grid-stack-item-content', appendTo: 'body'}\n   * @param root optional root which defaults to document (for shadow dom pas the parent HTMLDocument)\n   */\n  static setupDragIn(dragIn, dragInOptions, root = document) {\n    if (dragInOptions?.pause !== undefined) {\n      DDManager.pauseDrag = dragInOptions.pause;\n    }\n    dragInOptions = {\n      ...dragInDefaultOptions,\n      ...(dragInOptions || {})\n    };\n    let els = typeof dragIn === 'string' ? Utils.getElements(dragIn, root) : dragIn;\n    if (els.length) els?.forEach(el => {\n      if (!dd.isDraggable(el)) dd.dragIn(el, dragInOptions);\n    });\n  }\n  /**\n   * Enables/Disables dragging by the user of specific grid element. If you want all items, and have it affect future items, use enableMove() instead. No-op for static grids.\n   * IF you are looking to prevent an item from moving (due to being pushed around by another during collision) use locked property instead.\n   * @param els widget or selector to modify.\n   * @param val if true widget will be draggable, assuming the parent grid isn't noMove or static.\n   */\n  movable(els, val) {\n    if (this.opts.staticGrid) return this; // can't move a static grid!\n    GridStack.getElements(els).forEach(el => {\n      const n = el.gridstackNode;\n      if (!n) return;\n      val ? delete n.noMove : n.noMove = true;\n      this._prepareDragDropByNode(n); // init DD if need be, and adjust\n    });\n    return this;\n  }\n  /**\n   * Enables/Disables user resizing of specific grid element. If you want all items, and have it affect future items, use enableResize() instead. No-op for static grids.\n   * @param els  widget or selector to modify\n   * @param val  if true widget will be resizable, assuming the parent grid isn't noResize or static.\n   */\n  resizable(els, val) {\n    if (this.opts.staticGrid) return this; // can't resize a static grid!\n    GridStack.getElements(els).forEach(el => {\n      let n = el.gridstackNode;\n      if (!n) return;\n      val ? delete n.noResize : n.noResize = true;\n      this._prepareDragDropByNode(n); // init DD if need be, and adjust\n    });\n    return this;\n  }\n  /**\n   * Temporarily disables widgets moving/resizing.\n   * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.\n   * Note: no-op for static grid\n   * This is a shortcut for:\n   * @example\n   *  grid.enableMove(false);\n   *  grid.enableResize(false);\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  disable(recurse = true) {\n    if (this.opts.staticGrid) return;\n    this.enableMove(false, recurse);\n    this.enableResize(false, recurse);\n    this._triggerEvent('disable');\n    return this;\n  }\n  /**\n   * Re-enables widgets moving/resizing - see disable().\n   * Note: no-op for static grid.\n   * This is a shortcut for:\n   * @example\n   *  grid.enableMove(true);\n   *  grid.enableResize(true);\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  enable(recurse = true) {\n    if (this.opts.staticGrid) return;\n    this.enableMove(true, recurse);\n    this.enableResize(true, recurse);\n    this._triggerEvent('enable');\n    return this;\n  }\n  /**\n   * Enables/disables widget moving. No-op for static grids, and locally defined items still overrule\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  enableMove(doEnable, recurse = true) {\n    if (this.opts.staticGrid) return this; // can't move a static grid!\n    doEnable ? delete this.opts.disableDrag : this.opts.disableDrag = true; // FIRST before we update children as grid overrides #1658\n    this.engine.nodes.forEach(n => {\n      this._prepareDragDropByNode(n);\n      if (n.subGrid && recurse) n.subGrid.enableMove(doEnable, recurse);\n    });\n    return this;\n  }\n  /**\n   * Enables/disables widget resizing. No-op for static grids.\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  enableResize(doEnable, recurse = true) {\n    if (this.opts.staticGrid) return this; // can't size a static grid!\n    doEnable ? delete this.opts.disableResize : this.opts.disableResize = true; // FIRST before we update children as grid overrides #1658\n    this.engine.nodes.forEach(n => {\n      this._prepareDragDropByNode(n);\n      if (n.subGrid && recurse) n.subGrid.enableResize(doEnable, recurse);\n    });\n    return this;\n  }\n  /** @internal removes any drag&drop present (called during destroy) */\n  _removeDD(el) {\n    dd.draggable(el, 'destroy').resizable(el, 'destroy');\n    if (el.gridstackNode) {\n      delete el.gridstackNode._initDD; // reset our DD init flag\n    }\n    delete el.ddElement;\n    return this;\n  }\n  /** @internal called to add drag over to support widgets being added externally */\n  _setupAcceptWidget() {\n    // check if we need to disable things\n    if (this.opts.staticGrid || !this.opts.acceptWidgets && !this.opts.removable) {\n      dd.droppable(this.el, 'destroy');\n      return this;\n    }\n    // vars shared across all methods\n    let cellHeight, cellWidth;\n    let onDrag = (event, el, helper) => {\n      let node = el.gridstackNode;\n      if (!node) return;\n      helper = helper || el;\n      // if the element is being dragged from outside, scale it down to match the grid's scale\n      // and slightly adjust its position relative to the mouse\n      if (!node.grid?.el) {\n        // this scales the helper down\n        helper.style.transform = `scale(${1 / this.dragTransform.xScale},${1 / this.dragTransform.yScale})`;\n        // this makes it so that the helper is well positioned relative to the mouse after scaling\n        const helperRect = helper.getBoundingClientRect();\n        helper.style.left = helperRect.x + (this.dragTransform.xScale - 1) * (event.clientX - helperRect.x) / this.dragTransform.xScale + 'px';\n        helper.style.top = helperRect.y + (this.dragTransform.yScale - 1) * (event.clientY - helperRect.y) / this.dragTransform.yScale + 'px';\n        helper.style.transformOrigin = `0px 0px`;\n      }\n      let parent = this.el.getBoundingClientRect();\n      let {\n        top,\n        left\n      } = helper.getBoundingClientRect();\n      left -= parent.left;\n      top -= parent.top;\n      let ui = {\n        position: {\n          top: top * this.dragTransform.xScale,\n          left: left * this.dragTransform.yScale\n        }\n      };\n      if (node._temporaryRemoved) {\n        node.x = Math.max(0, Math.round(left / cellWidth));\n        node.y = Math.max(0, Math.round(top / cellHeight));\n        delete node.autoPosition;\n        this.engine.nodeBoundFix(node);\n        // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere\n        if (!this.engine.willItFit(node)) {\n          node.autoPosition = true; // ignore x,y and try for any slot...\n          if (!this.engine.willItFit(node)) {\n            dd.off(el, 'drag'); // stop calling us\n            return; // full grid or can't grow\n          }\n          if (node._willFitPos) {\n            // use the auto position instead #1687\n            Utils.copyPos(node, node._willFitPos);\n            delete node._willFitPos;\n          }\n        }\n        // re-use the existing node dragging method\n        this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);\n      } else {\n        // re-use the existing node dragging that does so much of the collision detection\n        this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);\n      }\n    };\n    dd.droppable(this.el, {\n      accept: el => {\n        let node = el.gridstackNode || this._readAttr(el, false);\n        // set accept drop to true on ourself (which we ignore) so we don't get \"can't drop\" icon in HTML5 mode while moving\n        if (node?.grid === this) return true;\n        if (!this.opts.acceptWidgets) return false;\n        // check for accept method or class matching\n        let canAccept = true;\n        if (typeof this.opts.acceptWidgets === 'function') {\n          canAccept = this.opts.acceptWidgets(el);\n        } else {\n          let selector = this.opts.acceptWidgets === true ? '.grid-stack-item' : this.opts.acceptWidgets;\n          canAccept = el.matches(selector);\n        }\n        // finally check to make sure we actually have space left #1571 #2633\n        if (canAccept && node && this.opts.maxRow) {\n          let n = {\n            w: node.w,\n            h: node.h,\n            minW: node.minW,\n            minH: node.minH\n          }; // only width/height matters and autoPosition\n          canAccept = this.engine.willItFit(n);\n        }\n        return canAccept;\n      }\n    })\n    /**\n     * entering our grid area\n     */.on(this.el, 'dropover', (event, el, helper) => {\n      // console.log(`over ${this.el.gridstack.opts.id} ${count++}`); // TEST\n      let node = el.gridstackNode;\n      // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item\n      if (node?.grid === this && !node._temporaryRemoved) {\n        // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)\n        return false; // prevent parent from receiving msg (which may be a grid as well)\n      }\n      // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now\n      if (node?.grid && node.grid !== this && !node._temporaryRemoved) {\n        // console.log('dropover without leave'); // TEST\n        let otherGrid = node.grid;\n        otherGrid._leave(el, helper);\n      }\n      // cache cell dimensions (which don't change), position can animate if we removed an item in otherGrid that affects us...\n      cellWidth = this.cellWidth();\n      cellHeight = this.getCellHeight(true);\n      // load any element attributes if we don't have a node\n      if (!node) {\n        node = this._readAttr(el, false); // don't wipe external (e.g. drag toolbar) attr #2354\n      }\n      if (!node.grid) {\n        node._isExternal = true;\n        el.gridstackNode = node;\n      }\n      // calculate the grid size based on element outer size\n      helper = helper || el;\n      let w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;\n      let h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;\n      // if the item came from another grid, make a copy and save the original info in case we go back there\n      if (node.grid && node.grid !== this) {\n        // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific\n        // console.log('dropover cloning node'); // TEST\n        if (!el._gridstackNodeOrig) el._gridstackNodeOrig = node; // shouldn't have multiple nested!\n        el.gridstackNode = node = {\n          ...node,\n          w,\n          h,\n          grid: this\n        };\n        delete node.x;\n        delete node.y;\n        this.engine.cleanupNode(node).nodeBoundFix(node);\n        // restore some internal fields we need after clearing them all\n        node._initDD = node._isExternal =\n        // DOM needs to be re-parented on a drop\n        node._temporaryRemoved = true; // so it can be inserted onDrag below\n      } else {\n        node.w = w;\n        node.h = h;\n        node._temporaryRemoved = true; // so we can insert it\n      }\n      // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)\n      GridStack._itemRemoving(node.el, false);\n      dd.on(el, 'drag', onDrag);\n      // make sure this is called at least once when going fast #1578\n      onDrag(event, el, helper);\n      return false; // prevent parent from receiving msg (which may be a grid as well)\n    })\n    /**\n     * Leaving our grid area...\n     */.on(this.el, 'dropout', (event, el, helper) => {\n      // console.log(`out ${this.el.gridstack.opts.id} ${count++}`); // TEST\n      let node = el.gridstackNode;\n      if (!node) return false;\n      // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)\n      // so skip this one if we're not the active grid really..\n      if (!node.grid || node.grid === this) {\n        this._leave(el, helper);\n        // if we were created as temporary nested grid, go back to before state\n        if (this._isTemp) {\n          this.removeAsSubGrid(node);\n        }\n      }\n      return false; // prevent parent from receiving msg (which may be grid as well)\n    })\n    /**\n     * end - releasing the mouse\n     */.on(this.el, 'drop', (event, el, helper) => {\n      let node = el.gridstackNode;\n      // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead\n      if (node?.grid === this && !node._isExternal) return false;\n      const wasAdded = !!this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419\n      this.placeholder.remove();\n      // disable animation when replacing a placeholder (already positioned) with actual content\n      const noAnim = wasAdded && this.opts.animate;\n      if (noAnim) this.setAnimation(false);\n      // notify previous grid of removal\n      // console.log('drop delete _gridstackNodeOrig') // TEST\n      let origNode = el._gridstackNodeOrig;\n      delete el._gridstackNodeOrig;\n      if (wasAdded && origNode?.grid && origNode.grid !== this) {\n        let oGrid = origNode.grid;\n        oGrid.engine.removeNodeFromLayoutCache(origNode);\n        oGrid.engine.removedNodes.push(origNode);\n        oGrid._triggerRemoveEvent()._triggerChangeEvent();\n        // if it's an empty sub-grid that got auto-created, nuke it\n        if (oGrid.parentGridItem && !oGrid.engine.nodes.length && oGrid.opts.subGridDynamic) {\n          oGrid.removeAsSubGrid();\n        }\n      }\n      if (!node) return false;\n      // use existing placeholder node as it's already in our list with drop location\n      if (wasAdded) {\n        this.engine.cleanupNode(node); // removes all internal _xyz values\n        node.grid = this;\n      }\n      delete node.grid?._isTemp;\n      dd.off(el, 'drag');\n      // if we made a copy ('helper' which is temp) of the original node then insert a copy, else we move the original node (#1102)\n      // as the helper will be nuked by jquery-ui otherwise. TODO: update old code path\n      if (helper !== el) {\n        helper.remove();\n        el.gridstackNode = origNode; // original item (left behind) is re-stored to pre dragging as the node now has drop info\n        if (wasAdded) {\n          el = el.cloneNode(true);\n        }\n      } else {\n        el.remove(); // reduce flicker as we change depth here, and size further down\n        this._removeDD(el);\n      }\n      if (!wasAdded) return false;\n      el.gridstackNode = node;\n      node.el = el;\n      let subGrid = node.subGrid?.el?.gridstack; // set when actual sub-grid present\n      // @ts-ignore\n      Utils.copyPos(node, this._readAttr(this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578\n      Utils.removePositioningStyles(el); // @ts-ignore\n      this.el.appendChild(el); // @ts-ignore // TODO: now would be ideal time to _removeHelperStyle() overriding floating styles (native only)\n      this._prepareElement(el, true, node);\n      if (subGrid) {\n        subGrid.parentGridItem = node;\n        if (!subGrid.opts.styleInHead) subGrid._updateStyles(true); // re-create sub-grid styles now that we've moved\n      }\n      this._updateContainerHeight();\n      this.engine.addedNodes.push(node); // @ts-ignore\n      this._triggerAddEvent(); // @ts-ignore\n      this._triggerChangeEvent();\n      this.engine.endUpdate();\n      if (this._gsEventHandler['dropped']) {\n        this._gsEventHandler['dropped']({\n          ...event,\n          type: 'dropped'\n        }, origNode && origNode.grid ? origNode : undefined, node);\n      }\n      // delay adding animation back\n      if (noAnim) this.setAnimation(this.opts.animate, true);\n      return false; // prevent parent from receiving msg (which may be grid as well)\n    });\n    return this;\n  }\n  /** @internal mark item for removal */\n  static _itemRemoving(el, remove) {\n    const node = el ? el.gridstackNode : undefined;\n    if (!node?.grid || el.classList.contains(node.grid.opts.removableOptions.decline)) return;\n    remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;\n    remove ? el.classList.add('grid-stack-item-removing') : el.classList.remove('grid-stack-item-removing');\n  }\n  /** @internal called to setup a trash drop zone if the user specifies it */\n  _setupRemoveDrop() {\n    if (typeof this.opts.removable !== 'string') return this;\n    let trashEl = document.querySelector(this.opts.removable);\n    if (!trashEl) return this;\n    // only register ONE static drop-over/dropout callback for the 'trash', and it will\n    // update the passed in item and parent grid because the '.trash' is a shared resource anyway,\n    // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)\n    if (!this.opts.staticGrid && !dd.isDroppable(trashEl)) {\n      dd.droppable(trashEl, this.opts.removableOptions).on(trashEl, 'dropover', (event, el) => GridStack._itemRemoving(el, true)).on(trashEl, 'dropout', (event, el) => GridStack._itemRemoving(el, false));\n    }\n    return this;\n  }\n  /** @internal prepares the element for drag&drop */\n  _prepareDragDropByNode(node) {\n    let el = node.el;\n    const noMove = node.noMove || this.opts.disableDrag;\n    const noResize = node.noResize || this.opts.disableResize;\n    // check for disabled grid first\n    if (this.opts.staticGrid || noMove && noResize) {\n      if (node._initDD) {\n        this._removeDD(el); // nukes everything instead of just disable, will add some styles back next\n        delete node._initDD;\n      }\n      el.classList.add('ui-draggable-disabled', 'ui-resizable-disabled'); // add styles one might depend on #1435\n      return this;\n    }\n    if (!node._initDD) {\n      // variables used/cashed between the 3 start/move/end methods, in addition to node passed above\n      let cellWidth;\n      let cellHeight;\n      /** called when item starts moving/resizing */\n      let onStartMoving = (event, ui) => {\n        // trigger any 'dragstart' / 'resizestart' manually\n        if (this._gsEventHandler[event.type]) {\n          this._gsEventHandler[event.type](event, event.target);\n        }\n        cellWidth = this.cellWidth();\n        cellHeight = this.getCellHeight(true); // force pixels for calculations\n        this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);\n      };\n      /** called when item is being dragged/resized */\n      let dragOrResize = (event, ui) => {\n        this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);\n      };\n      /** called when the item stops moving/resizing */\n      let onEndMoving = event => {\n        this.placeholder.remove();\n        delete node._moving;\n        delete node._event;\n        delete node._lastTried;\n        const widthChanged = node.w !== node._orig.w;\n        // if the item has moved to another grid, we're done here\n        let target = event.target;\n        if (!target.gridstackNode || target.gridstackNode.grid !== this) return;\n        node.el = target;\n        if (node._isAboutToRemove) {\n          let grid = el.gridstackNode.grid;\n          if (grid._gsEventHandler[event.type]) {\n            grid._gsEventHandler[event.type](event, target);\n          }\n          grid.engine.nodes.push(node); // temp add it back so we can proper remove it next\n          grid.removeWidget(el, true, true);\n        } else {\n          Utils.removePositioningStyles(target);\n          if (node._temporaryRemoved) {\n            // got removed - restore item back to before dragging position\n            Utils.copyPos(node, node._orig); // @ts-ignore\n            this._writePosAttr(target, node);\n            this.engine.addNode(node);\n          } else {\n            // move to new placeholder location\n            this._writePosAttr(target, node);\n          }\n          if (this._gsEventHandler[event.type]) {\n            this._gsEventHandler[event.type](event, target);\n          }\n        }\n        // @ts-ignore\n        this._extraDragRow = 0; // @ts-ignore\n        this._updateContainerHeight(); // @ts-ignore\n        this._triggerChangeEvent();\n        this.engine.endUpdate();\n        if (event.type === 'resizestop') {\n          if (Number.isInteger(node.sizeToContent)) node.sizeToContent = node.h; // new soft limit\n          this.resizeToContentCheck(widthChanged, node); // wait for width animation if changed\n        }\n      };\n      dd.draggable(el, {\n        start: onStartMoving,\n        stop: onEndMoving,\n        drag: dragOrResize\n      }).resizable(el, {\n        start: onStartMoving,\n        stop: onEndMoving,\n        resize: dragOrResize\n      });\n      node._initDD = true; // we've set DD support now\n    }\n    // finally fine tune move vs resize by disabling any part...\n    dd.draggable(el, noMove ? 'disable' : 'enable').resizable(el, noResize ? 'disable' : 'enable');\n    return this;\n  }\n  /** @internal handles actual drag/resize start */\n  _onStartMoving(el, event, ui, node, cellWidth, cellHeight) {\n    this.engine.cleanNodes().beginUpdate(node);\n    // @ts-ignore\n    this._writePosAttr(this.placeholder, node);\n    this.el.appendChild(this.placeholder);\n    this.placeholder.gridstackNode = node;\n    // console.log('_onStartMoving placeholder') // TEST\n    // if the element is inside a grid, it has already been scaled\n    // we can use that as a scale reference\n    if (node.grid?.el) {\n      this.dragTransform = Utils.getValuesFromTransformedElement(el);\n    }\n    // if the element is being dragged from outside (not from any grid)\n    // we use the grid as the transformation reference, since the helper is not subject to transformation\n    else if (this.placeholder && this.placeholder.closest('.grid-stack')) {\n      const gridEl = this.placeholder.closest('.grid-stack');\n      this.dragTransform = Utils.getValuesFromTransformedElement(gridEl);\n    }\n    // Fallback\n    else {\n      this.dragTransform = {\n        xScale: 1,\n        xOffset: 0,\n        yScale: 1,\n        yOffset: 0\n      };\n    }\n    node.el = this.placeholder;\n    node._lastUiPosition = ui.position;\n    node._prevYPix = ui.position.top;\n    node._moving = event.type === 'dragstart'; // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)\n    delete node._lastTried;\n    if (event.type === 'dropover' && node._temporaryRemoved) {\n      // console.log('engine.addNode x=' + node.x); // TEST\n      this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved\n      node._moving = true; // AFTER, mark as moving object (wanted fix location before)\n    }\n    // set the min/max resize info taking into account the column count and position (so we don't resize outside the grid)\n    this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop, this.opts.marginRight, this.opts.marginBottom, this.opts.marginLeft);\n    if (event.type === 'resizestart') {\n      const colLeft = this.getColumn() - node.x;\n      const rowLeft = (this.opts.maxRow || Number.MAX_SAFE_INTEGER) - node.y;\n      dd.resizable(el, 'option', 'minWidth', cellWidth * Math.min(node.minW || 1, colLeft)).resizable(el, 'option', 'minHeight', cellHeight * Math.min(node.minH || 1, rowLeft)).resizable(el, 'option', 'maxWidth', cellWidth * Math.min(node.maxW || Number.MAX_SAFE_INTEGER, colLeft)).resizable(el, 'option', 'maxWidthMoveLeft', cellWidth * Math.min(node.maxW || Number.MAX_SAFE_INTEGER, node.x + node.w)).resizable(el, 'option', 'maxHeight', cellHeight * Math.min(node.maxH || Number.MAX_SAFE_INTEGER, rowLeft)).resizable(el, 'option', 'maxHeightMoveUp', cellHeight * Math.min(node.maxH || Number.MAX_SAFE_INTEGER, node.y + node.h));\n    }\n  }\n  /** @internal handles actual drag/resize */\n  _dragOrResize(el, event, ui, node, cellWidth, cellHeight) {\n    let p = {\n      ...node._orig\n    }; // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)\n    let resizing;\n    let mLeft = this.opts.marginLeft,\n      mRight = this.opts.marginRight,\n      mTop = this.opts.marginTop,\n      mBottom = this.opts.marginBottom;\n    // if margins (which are used to pass mid point by) are large relative to cell height/width, reduce them down #1855\n    let mHeight = Math.round(cellHeight * 0.1),\n      mWidth = Math.round(cellWidth * 0.1);\n    mLeft = Math.min(mLeft, mWidth);\n    mRight = Math.min(mRight, mWidth);\n    mTop = Math.min(mTop, mHeight);\n    mBottom = Math.min(mBottom, mHeight);\n    if (event.type === 'drag') {\n      if (node._temporaryRemoved) return; // handled by dropover\n      let distance = ui.position.top - node._prevYPix;\n      node._prevYPix = ui.position.top;\n      if (this.opts.draggable.scroll !== false) {\n        Utils.updateScrollPosition(el, ui.position, distance);\n      }\n      // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)\n      let left = ui.position.left + (ui.position.left > node._lastUiPosition.left ? -mRight : mLeft);\n      let top = ui.position.top + (ui.position.top > node._lastUiPosition.top ? -mBottom : mTop);\n      p.x = Math.round(left / cellWidth);\n      p.y = Math.round(top / cellHeight);\n      // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others\n      let prev = this._extraDragRow;\n      if (this.engine.collide(node, p)) {\n        let row = this.getRow();\n        let extra = Math.max(0, p.y + node.h - row);\n        if (this.opts.maxRow && row + extra > this.opts.maxRow) {\n          extra = Math.max(0, this.opts.maxRow - row);\n        } // @ts-ignore\n        this._extraDragRow = extra; // @ts-ignore\n      } else this._extraDragRow = 0; // @ts-ignore\n      if (this._extraDragRow !== prev) this._updateContainerHeight();\n      if (node.x === p.x && node.y === p.y) return; // skip same\n      // DON'T skip one we tried as we might have failed because of coverage <50% before\n      // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;\n    } else if (event.type === 'resize') {\n      if (p.x < 0) return;\n      // Scrolling page if needed\n      Utils.updateScrollResize(event, el, cellHeight);\n      // get new size\n      p.w = Math.round((ui.size.width - mLeft) / cellWidth);\n      p.h = Math.round((ui.size.height - mTop) / cellHeight);\n      if (node.w === p.w && node.h === p.h) return;\n      if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h) return; // skip one we tried (but failed)\n      // if we size on left/top side this might move us, so get possible new position as well\n      let left = ui.position.left + mLeft;\n      let top = ui.position.top + mTop;\n      p.x = Math.round(left / cellWidth);\n      p.y = Math.round(top / cellHeight);\n      resizing = true;\n    }\n    node._event = event;\n    node._lastTried = p; // set as last tried (will nuke if we go there)\n    let rect = {\n      x: ui.position.left + mLeft,\n      y: ui.position.top + mTop,\n      w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,\n      h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom\n    };\n    if (this.engine.moveNodeCheck(node, {\n      ...p,\n      cellWidth,\n      cellHeight,\n      rect,\n      resizing\n    })) {\n      node._lastUiPosition = ui.position;\n      this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);\n      delete node._skipDown;\n      if (resizing && node.subGrid) node.subGrid.onResize();\n      this._extraDragRow = 0; // @ts-ignore\n      this._updateContainerHeight();\n      let target = event.target; // @ts-ignore\n      this._writePosAttr(target, node);\n      if (this._gsEventHandler[event.type]) {\n        this._gsEventHandler[event.type](event, target);\n      }\n    }\n  }\n  /** @internal called when item leaving our area by either cursor dropout event\n   * or shape is outside our boundaries. remove it from us, and mark temporary if this was\n   * our item to start with else restore prev node values from prev grid it came from.\n   */\n  _leave(el, helper) {\n    let node = el.gridstackNode;\n    if (!node) return;\n    helper = helper || el;\n    // restore the scale of the helper on leave\n    helper.style.transform = 'scale(1)';\n    dd.off(el, 'drag'); // no need to track while being outside\n    // this gets called when cursor leaves and shape is outside, so only do this once\n    if (node._temporaryRemoved) return;\n    node._temporaryRemoved = true;\n    this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue\n    node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged\n    if (this.opts.removable === true) {\n      // boolean vs a class string\n      // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so\n      GridStack._itemRemoving(el, true);\n    }\n    // finally if item originally came from another grid, but left us, restore things back to prev info\n    if (el._gridstackNodeOrig) {\n      // console.log('leave delete _gridstackNodeOrig') // TEST\n      el.gridstackNode = el._gridstackNodeOrig;\n      delete el._gridstackNodeOrig;\n    } else if (node._isExternal) {\n      // item came from outside (like a toolbar) so nuke any node info\n      delete node.el;\n      delete el.gridstackNode;\n      // and restore all nodes back to original\n      this.engine.restoreInitial();\n    }\n  }\n  // legacy method removed\n  commit() {\n    obsolete(this, this.batchUpdate(false), 'commit', 'batchUpdate', '5.2');\n    return this;\n  }\n}\n/** parent class for sizing content. defaults to '.grid-stack-item-content' */\nGridStack.resizeToContentParent = '.grid-stack-item-content';\n/** scoping so users can call GridStack.Utils.sort() for example */\nGridStack.Utils = Utils;\n/** scoping so users can call new GridStack.Engine(12) for example */\nGridStack.Engine = GridStackEngine;\nGridStack.GDRev = '10.3.1';\nexport { GridStack };","map":{"version":3,"names":["GridStackEngine","Utils","obsolete","gridDefaults","dragInDefaultOptions","DDGridStack","isTouch","DDManager","dd","GridStack","init","options","elOrString","document","el","getGridElement","console","error","gridstack","cloneDeep","initAll","selector","grids","getGridElements","forEach","push","length","addGrid","parent","opt","grid","opts","children","undefined","load","parentIsGrid","classList","contains","addRemoveCB","doc","implementation","createHTMLDocument","body","innerHTML","class","appendChild","registerEngine","engineClass","placeholder","_placeholder","placeholderChild","createElement","className","placeholderText","add","placeholderClass","itemClass","constructor","_gsEventHandler","_extraDragRow","dragTransform","xScale","yScale","xOffset","yOffset","row","minRow","maxRow","rowAttr","toNumber","getAttribute","column","alwaysShowResizeHandle","_alwaysShowResizeHandle","bk","columnOpts","breakpoints","oldOpts","oneColumnModeDomSort","log","oneColumnSize","disableOneColumnMode","oneSize","oneColumn","find","b","c","w","resp","columnWidth","columnMax","sort","a","defaults","staticGrid","toBool","draggable","handle","handleClass","removableOptions","accept","decline","animate","_initMargin","checkDynamicColumn","rtl","style","direction","grandParent","parentElement","parentGridItem","gridstackNode","subGrid","_isAutoCellHeight","cellHeight","cellHeightUnit","_styleSheetClass","_idSeq","_setStaticClass","engine","getColumn","float","onChange","cbNodes","maxH","nodes","n","Math","max","y","h","_removeDOM","remove","_writePosAttr","_updateStyles","auto","batchUpdate","_loading","getGridItems","_prepareElement","setAnimation","subGridDynamic","pauseDrag","pause","_setupRemoveDrop","_setupAcceptWidget","_updateResizeEvent","addWidget","els","isGridStackWidget","x","content","node","arguments","_id","domAttr","_readAttr","prepareNode","_writeAttr","makeWidget","makeSubGrid","ops","nodeToAdd","saveContent","subGridTemplate","subGridOpts","autoColumn","querySelector","newItem","newItemOpt","_removeDD","removeInternalForSave","_prepareDragDropByNode","transition","update","setTimeout","_moving","_isTemp","_autoColumn","window","simulateMouseEvent","_event","removeAsSubGrid","nodeThatRemoved","pGrid","removeWidget","save","saveGridOpt","saveCB","list","sub","listOrOpt","o","marginBottom","marginTop","marginRight","marginLeft","margin","origShow","removeInternalAndSame","items","addRemove","maxColumn","_ignoreLayoutsNodeChange","cacheLayout","prevCB","removed","blank","copyNodes","id","item","updateNodes","filter","shouldSizeToContent","nodeBoundFix","autoPosition","findEmptyPosition","samePos","moveNode","forceCollide","removedNodes","flag","_updateContainerHeight","_triggerRemoveEvent","_triggerAddEvent","_triggerChangeEvent","getCellHeight","forcePixel","parseFloat","getComputedStyle","documentElement","fontSize","round","offsetHeight","rows","parseInt","getBoundingClientRect","height","val","marginDiff","cellWidth","data","parseHeight","unit","resizeToContentCheck","_widthOrContainer","forBreakpoint","breakpointForWindow","innerWidth","clientWidth","newColumn","min","i","layout","compact","doSort","oldColumn","columnChanged","Array","from","matches","destroy","removeDOM","offAll","setStatic","removeAll","removeAttribute","parentNode","removeChild","_removeStylesheet","getFloat","getCellFromPixel","position","useDocRelative","box","containerPos","top","scrollTop","left","offsetTop","offsetLeft","relativeLeft","relativeTop","width","rowHeight","floor","getRow","isAreaEmpty","getElement","on","name","callback","indexOf","names","split","noData","event","detail","addEventListener","off","removeEventListener","Object","keys","key","triggerEvent","getElements","removeNode","doAnimate","delay","hasAnimationCSS","updateClass","recurse","warn","m","some","k","minW","minH","maxW","itemContent","styleInHead","changed","ddChanged","sanitizeMinMax","widthChanged","_orig","wasUpdating","_updating","cleanNodes","beginUpdate","endUpdate","resizeToContent","clientHeight","cell","resizeToContentParent","padding","itemH","wantedH","child","firstElementChild","ceil","softMax","Number","isInteger","sizeToContent","resizeToContentCBCheck","resizeToContentCB","rotate","relative","canBeRotated","rot","pivotX","pivotY","value","isMultiValue","marginUnit","getMargin","willItFit","batchMode","elements","getDirtyNodes","layoutsNodesChange","_triggerEvent","saveInitial","addedNodes","_dirty","type","CustomEvent","bubbles","Event","dispatchEvent","_styles","styleLocation","removeStylesheet","forceUpdate","prefix","createStylesheet","nonce","_max","addCSSRule","bottom","right","getHeight","cssMinHeight","setAttribute","String","removeProperty","triggerAddEvent","addNode","attrs","noResize","noMove","locked","clearDefaultAttr","hasOwnProperty","classes","onResize","prevWidth","_skipInitialResize","forceRemove","trackSize","resizeObserver","_sizeThrottle","throttle","cellHeightThrottle","ResizeObserver","observe","disconnect","margins","getDD","setupDragIn","dragIn","dragInOptions","root","isDraggable","movable","resizable","disable","enableMove","enableResize","enable","doEnable","disableDrag","disableResize","_initDD","ddElement","acceptWidgets","removable","droppable","onDrag","helper","transform","helperRect","clientX","clientY","transformOrigin","ui","_temporaryRemoved","_willFitPos","copyPos","_onStartMoving","_dragOrResize","canAccept","otherGrid","_leave","_isExternal","offsetWidth","_gridstackNodeOrig","cleanupNode","_itemRemoving","wasAdded","noAnim","origNode","oGrid","removeNodeFromLayoutCache","cloneNode","removePositioningStyles","_isAboutToRemove","trashEl","isDroppable","onStartMoving","target","dragOrResize","onEndMoving","_lastTried","start","stop","drag","resize","getValuesFromTransformedElement","closest","gridEl","_lastUiPosition","_prevYPix","cacheRects","colLeft","rowLeft","MAX_SAFE_INTEGER","p","resizing","mLeft","mRight","mTop","mBottom","mHeight","mWidth","distance","scroll","updateScrollPosition","prev","collide","extra","updateScrollResize","size","rect","moveNodeCheck","_skipDown","restoreInitial","commit","Engine","GDRev"],"sources":["../src/gridstack.ts"],"sourcesContent":["/*!\r\n * GridStack 10.3.1\r\n * https://gridstackjs.com/\r\n *\r\n * Copyright (c) 2021-2022 Alain Dumesny\r\n * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE\r\n */\r\nimport { GridStackEngine } from './gridstack-engine';\r\nimport { Utils, HeightData, obsolete, DragTransform } from './utils';\r\nimport {\r\n  gridDefaults, ColumnOptions, GridItemHTMLElement, GridStackElement, GridStackEventHandlerCallback,\r\n  GridStackNode, GridStackWidget, numberOrString, DDUIData, DDDragInOpt, GridStackPosition, GridStackOptions,\r\n  dragInDefaultOptions, GridStackEventHandler, GridStackNodesHandler, AddRemoveFcn, SaveFcn, CompactOptions, GridStackMoveOpts, ResizeToContentFcn, GridStackDroppedHandler, GridStackElementHandler,\r\n  Position\r\n} from './types';\r\n\r\n/*\r\n * and include D&D by default\r\n * TODO: while we could generate a gridstack-static.js at smaller size - saves about 31k (41k -> 72k)\r\n * I don't know how to generate the DD only code at the remaining 31k to delay load as code depends on Gridstack.ts\r\n * also it caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\r\n */\r\nimport { DDGridStack } from './dd-gridstack';\r\nimport { isTouch } from './dd-touch';\r\nimport { DDManager } from './dd-manager';\r\nimport { DDElementHost } from './dd-element';/** global instance */\r\nconst dd = new DDGridStack;\r\n\r\n// export all dependent file as well to make it easier for users to just import the main file\r\nexport * from './types';\r\nexport * from './utils';\r\nexport * from './gridstack-engine';\r\nexport * from './dd-gridstack';\r\n\r\nexport interface GridHTMLElement extends HTMLElement {\r\n  gridstack?: GridStack; // grid's parent DOM element points back to grid class\r\n}\r\n/** list of possible events, or space separated list of them */\r\nexport type GridStackEvent = 'added' | 'change' | 'disable' | 'drag' | 'dragstart' | 'dragstop' | 'dropped' |\r\n  'enable' | 'removed' | 'resize' | 'resizestart' | 'resizestop' | 'resizecontent';\r\n\r\n/** Defines the coordinates of an object */\r\nexport interface MousePosition {\r\n  top: number;\r\n  left: number;\r\n}\r\n\r\n/** Defines the position of a cell inside the grid*/\r\nexport interface CellPosition {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ninterface GridCSSStyleSheet extends CSSStyleSheet {\r\n  _max?: number; // internal tracker of the max # of rows we created\r\n}\r\n\r\n// extend with internal fields we need - TODO: move other items in here\r\ninterface InternalGridStackOptions extends GridStackOptions {\r\n  _alwaysShowResizeHandle?: true | false | 'mobile'; // so we can restore for save\r\n}\r\n\r\n// temporary legacy (<10.x) support\r\ninterface OldOneColumnOpts extends GridStackOptions {\r\n  /** disables the onColumnMode when the grid width is less (default?: false) */\r\n  disableOneColumnMode?: boolean;\r\n  /** minimal width before grid will be shown in one column mode (default?: 768) */\r\n  oneColumnSize?: number;\r\n  /** set to true if you want oneColumnMode to use the DOM order and ignore x,y from normal multi column\r\n   layouts during sorting. This enables you to have custom 1 column layout that differ from the rest. (default?: false) */\r\n  oneColumnModeDomSort?: boolean;\r\n}\r\n\r\n/**\r\n * Main gridstack class - you will need to call `GridStack.init()` first to initialize your grid.\r\n * Note: your grid elements MUST have the following classes for the CSS layout to work:\r\n * @example\r\n * <div class=\"grid-stack\">\r\n *   <div class=\"grid-stack-item\">\r\n *     <div class=\"grid-stack-item-content\">Item 1</div>\r\n *   </div>\r\n * </div>\r\n */\r\nexport class GridStack {\r\n\r\n  /**\r\n   * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will\r\n   * simply return the existing instance (ignore any passed options). There is also an initAll() version that support\r\n   * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.\r\n   * @param options grid options (optional)\r\n   * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)\r\n   *\r\n   * @example\r\n   * let grid = GridStack.init();\r\n   *\r\n   * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later\r\n   * let grid = document.querySelector('.grid-stack').gridstack;\r\n   */\r\n  public static init(options: GridStackOptions = {}, elOrString: GridStackElement = '.grid-stack'): GridStack {\r\n    if (typeof document === 'undefined') return null; // temp workaround SSR\r\n    let el = GridStack.getGridElement(elOrString);\r\n    if (!el) {\r\n      if (typeof elOrString === 'string') {\r\n        console.error('GridStack.initAll() no grid was found with selector \"' + elOrString + '\" - element missing or wrong selector ?' +\r\n          '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\r\n      } else {\r\n        console.error('GridStack.init() no grid element was passed.');\r\n      }\r\n      return null;\r\n    }\r\n    if (!el.gridstack) {\r\n      el.gridstack = new GridStack(el, Utils.cloneDeep(options));\r\n    }\r\n    return el.gridstack\r\n  }\r\n\r\n  /**\r\n   * Will initialize a list of elements (given a selector) and return an array of grids.\r\n   * @param options grid options (optional)\r\n   * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)\r\n   *\r\n   * @example\r\n   * let grids = GridStack.initAll();\r\n   * grids.forEach(...)\r\n   */\r\n  public static initAll(options: GridStackOptions = {}, selector = '.grid-stack'): GridStack[] {\r\n    let grids: GridStack[] = [];\r\n    if (typeof document === 'undefined') return grids; // temp workaround SSR\r\n    GridStack.getGridElements(selector).forEach(el => {\r\n      if (!el.gridstack) {\r\n        el.gridstack = new GridStack(el, Utils.cloneDeep(options));\r\n      }\r\n      grids.push(el.gridstack);\r\n    });\r\n    if (grids.length === 0) {\r\n      console.error('GridStack.initAll() no grid was found with selector \"' + selector + '\" - element missing or wrong selector ?' +\r\n        '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\r\n    }\r\n    return grids;\r\n  }\r\n\r\n  /**\r\n   * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then\r\n   * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from\r\n   * JSON serialized data, including options.\r\n   * @param parent HTML element parent to the grid\r\n   * @param opt grids options used to initialize the grid, and list of children\r\n   */\r\n  public static addGrid(parent: HTMLElement, opt: GridStackOptions = {}): GridStack {\r\n    if (!parent) return null;\r\n\r\n    let el = parent as GridHTMLElement;\r\n    if (el.gridstack) {\r\n      // already a grid - set option and load data\r\n      const grid = el.gridstack;\r\n      if (opt) grid.opts = { ...grid.opts, ...opt };\r\n      if (opt.children !== undefined) grid.load(opt.children);\r\n      return grid;\r\n    }\r\n\r\n    // create the grid element, but check if the passed 'parent' already has grid styling and should be used instead\r\n    const parentIsGrid = parent.classList.contains('grid-stack');\r\n    if (!parentIsGrid || GridStack.addRemoveCB) {\r\n      if (GridStack.addRemoveCB) {\r\n        el = GridStack.addRemoveCB(parent, opt, true, true);\r\n      } else {\r\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\r\n        doc.body.innerHTML = `<div class=\"grid-stack ${opt.class || ''}\"></div>`;\r\n        el = doc.body.children[0] as HTMLElement;\r\n        parent.appendChild(el);\r\n      }\r\n    }\r\n\r\n    // create grid class and load any children\r\n    let grid = GridStack.init(opt, el);\r\n    return grid;\r\n  }\r\n\r\n  /** call this method to register your engine instead of the default one.\r\n   * See instead `GridStackOptions.engineClass` if you only need to\r\n   * replace just one instance.\r\n   */\r\n  static registerEngine(engineClass: typeof GridStackEngine): void {\r\n    GridStack.engineClass = engineClass;\r\n  }\r\n\r\n  /**\r\n   * callback method use when new items|grids needs to be created or deleted, instead of the default\r\n   * item: <div class=\"grid-stack-item\"><div class=\"grid-stack-item-content\">w.content</div></div>\r\n   * grid: <div class=\"grid-stack\">grid content...</div>\r\n   * add = true: the returned DOM element will then be converted to a GridItemHTMLElement using makeWidget()|GridStack:init().\r\n   * add = false: the item will be removed from DOM (if not already done)\r\n   * grid = true|false for grid vs grid-items\r\n   */\r\n  public static addRemoveCB?: AddRemoveFcn;\r\n\r\n  /**\r\n   * callback during saving to application can inject extra data for each widget, on top of the grid layout properties\r\n   */\r\n  public static saveCB?: SaveFcn;\r\n\r\n  /** callback to use for resizeToContent instead of the built in one */\r\n  public static resizeToContentCB?: ResizeToContentFcn;\r\n  /** parent class for sizing content. defaults to '.grid-stack-item-content' */\r\n  public static resizeToContentParent = '.grid-stack-item-content';\r\n\r\n  /** scoping so users can call GridStack.Utils.sort() for example */\r\n  public static Utils = Utils;\r\n\r\n  /** scoping so users can call new GridStack.Engine(12) for example */\r\n  public static Engine = GridStackEngine;\r\n\r\n  /** engine used to implement non DOM grid functionality */\r\n  public engine: GridStackEngine;\r\n\r\n  /** point to a parent grid item if we're nested (inside a grid-item in between 2 Grids) */\r\n  public parentGridItem?: GridStackNode;\r\n\r\n  protected static engineClass: typeof GridStackEngine;\r\n  protected resizeObserver: ResizeObserver;\r\n\r\n  /** @internal unique class name for our generated CSS style sheet */\r\n  protected _styleSheetClass?: string;\r\n  /** @internal true if we got created by drag over gesture, so we can removed on drag out (temporary) */\r\n  public _isTemp?: boolean;\r\n\r\n  /** @internal create placeholder DIV as needed */\r\n  public get placeholder(): GridItemHTMLElement {\r\n    if (!this._placeholder) {\r\n      let placeholderChild = document.createElement('div'); // child so padding match item-content\r\n      placeholderChild.className = 'placeholder-content';\r\n      if (this.opts.placeholderText) {\r\n        placeholderChild.innerHTML = this.opts.placeholderText;\r\n      }\r\n      this._placeholder = document.createElement('div');\r\n      this._placeholder.classList.add(this.opts.placeholderClass, gridDefaults.itemClass, this.opts.itemClass);\r\n      this.placeholder.appendChild(placeholderChild);\r\n    }\r\n    return this._placeholder;\r\n  }\r\n  /** @internal */\r\n  protected _placeholder: HTMLElement;\r\n  /** @internal prevent cached layouts from being updated when loading into small column layouts */\r\n  protected _ignoreLayoutsNodeChange: boolean;\r\n  /** @internal */\r\n  public _gsEventHandler = {};\r\n  /** @internal */\r\n  protected _styles: GridCSSStyleSheet;\r\n  /** @internal flag to keep cells square during resize */\r\n  protected _isAutoCellHeight: boolean;\r\n  /** @internal limit auto cell resizing method */\r\n  protected _sizeThrottle: () => void;\r\n  /** @internal limit auto cell resizing method */\r\n  protected prevWidth: number;\r\n  /** @internal extra row added when dragging at the bottom of the grid */\r\n  protected _extraDragRow = 0;\r\n  /** @internal true if nested grid should get column count from our width */\r\n  protected _autoColumn?: boolean;\r\n  /** @internal meant to store the scale of the active grid */\r\n  protected dragTransform: DragTransform = { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 };\r\n  private _skipInitialResize: boolean;\r\n\r\n  /**\r\n   * Construct a grid item from the given element and options\r\n   * @param el the HTML element tied to this grid after it's been initialized\r\n   * @param opts grid options - public for classes to access, but use methods to modify!\r\n   */\r\n  public constructor(public el: GridHTMLElement, public opts: GridStackOptions = {}) {\r\n    el.gridstack = this;\r\n    opts = opts || {}; // handles null/undefined/0\r\n\r\n    if (!el.classList.contains('grid-stack')) {\r\n      this.el.classList.add('grid-stack');\r\n    }\r\n\r\n    // if row property exists, replace minRow and maxRow instead\r\n    if (opts.row) {\r\n      opts.minRow = opts.maxRow = opts.row;\r\n      delete opts.row;\r\n    }\r\n    let rowAttr = Utils.toNumber(el.getAttribute('gs-row'));\r\n\r\n    // flag only valid in sub-grids (handled by parent, not here)\r\n    if (opts.column === 'auto') {\r\n      delete opts.column;\r\n    }\r\n    // save original setting so we can restore on save\r\n    if (opts.alwaysShowResizeHandle !== undefined) {\r\n      (opts as InternalGridStackOptions)._alwaysShowResizeHandle = opts.alwaysShowResizeHandle;\r\n    }\r\n    let bk = opts.columnOpts?.breakpoints;\r\n    // LEGACY: oneColumnMode stuff changed in v10.x - check if user explicitly set something to convert over\r\n    const oldOpts: OldOneColumnOpts = opts;\r\n    if (oldOpts.oneColumnModeDomSort) {\r\n      delete oldOpts.oneColumnModeDomSort;\r\n      console.log('warning: Gridstack oneColumnModeDomSort no longer supported. Use GridStackOptions.columnOpts instead.')\r\n    }\r\n    if (oldOpts.oneColumnSize || oldOpts.disableOneColumnMode === false) {\r\n      const oneSize = oldOpts.oneColumnSize || 768;\r\n      delete oldOpts.oneColumnSize;\r\n      delete oldOpts.disableOneColumnMode;\r\n      opts.columnOpts = opts.columnOpts || {};\r\n      bk = opts.columnOpts.breakpoints = opts.columnOpts.breakpoints || [];\r\n      let oneColumn = bk.find(b => b.c === 1);\r\n      if (!oneColumn) {\r\n        oneColumn = { c: 1, w: oneSize };\r\n        bk.push(oneColumn, { c: 12, w: oneSize + 1 });\r\n      } else oneColumn.w = oneSize;\r\n    }\r\n    //...end LEGACY\r\n    // cleanup responsive opts (must have columnWidth | breakpoints) then sort breakpoints by size (so we can match during resize)\r\n    const resp = opts.columnOpts;\r\n    if (resp) {\r\n      if (!resp.columnWidth && !resp.breakpoints?.length) {\r\n        delete opts.columnOpts;\r\n        bk = undefined;\r\n      } else {\r\n        resp.columnMax = resp.columnMax || 12;\r\n      }\r\n    }\r\n    if (bk?.length > 1) bk.sort((a, b) => (b.w || 0) - (a.w || 0));\r\n\r\n    // elements DOM attributes override any passed options (like CSS style) - merge the two together\r\n    let defaults: GridStackOptions = {\r\n      ...Utils.cloneDeep(gridDefaults),\r\n      column: Utils.toNumber(el.getAttribute('gs-column')) || gridDefaults.column,\r\n      minRow: rowAttr ? rowAttr : Utils.toNumber(el.getAttribute('gs-min-row')) || gridDefaults.minRow,\r\n      maxRow: rowAttr ? rowAttr : Utils.toNumber(el.getAttribute('gs-max-row')) || gridDefaults.maxRow,\r\n      staticGrid: Utils.toBool(el.getAttribute('gs-static')) || gridDefaults.staticGrid,\r\n      draggable: {\r\n        handle: (opts.handleClass ? '.' + opts.handleClass : (opts.handle ? opts.handle : '')) || gridDefaults.draggable.handle,\r\n      },\r\n      removableOptions: {\r\n        accept: opts.itemClass || gridDefaults.removableOptions.accept,\r\n        decline: gridDefaults.removableOptions.decline\r\n      },\r\n    };\r\n    if (el.getAttribute('gs-animate')) { // default to true, but if set to false use that instead\r\n      defaults.animate = Utils.toBool(el.getAttribute('gs-animate'))\r\n    }\r\n\r\n    opts = Utils.defaults(opts, defaults);\r\n    this._initMargin(); // part of settings defaults...\r\n\r\n    // Now check if we're loading into 1 column mode FIRST so we don't do un-necessary work (like cellHeight = width / 12 then go 1 column)\r\n    this.checkDynamicColumn();\r\n    this.el.classList.add('gs-' + opts.column);\r\n\r\n    if (opts.rtl === 'auto') {\r\n      opts.rtl = (el.style.direction === 'rtl');\r\n    }\r\n    if (opts.rtl) {\r\n      this.el.classList.add('grid-stack-rtl');\r\n    }\r\n\r\n    // check if we're been nested, and if so update our style and keep pointer around (used during save)\r\n    const grandParent: GridItemHTMLElement = this.el.parentElement?.parentElement;\r\n    let parentGridItem = grandParent?.classList.contains(gridDefaults.itemClass) ? grandParent.gridstackNode : undefined;\r\n    if (parentGridItem) {\r\n      parentGridItem.subGrid = this;\r\n      this.parentGridItem = parentGridItem;\r\n      this.el.classList.add('grid-stack-nested');\r\n      parentGridItem.el.classList.add('grid-stack-sub-grid');\r\n    }\r\n\r\n    this._isAutoCellHeight = (opts.cellHeight === 'auto');\r\n    if (this._isAutoCellHeight || opts.cellHeight === 'initial') {\r\n      // make the cell content square initially (will use resize/column event to keep it square)\r\n      this.cellHeight(undefined, false);\r\n    } else {\r\n      // append unit if any are set\r\n      if (typeof opts.cellHeight == 'number' && opts.cellHeightUnit && opts.cellHeightUnit !== gridDefaults.cellHeightUnit) {\r\n        opts.cellHeight = opts.cellHeight + opts.cellHeightUnit;\r\n        delete opts.cellHeightUnit;\r\n      }\r\n      this.cellHeight(opts.cellHeight, false);\r\n    }\r\n\r\n    // see if we need to adjust auto-hide\r\n    if (opts.alwaysShowResizeHandle === 'mobile') {\r\n      opts.alwaysShowResizeHandle = isTouch;\r\n    }\r\n\r\n    this._styleSheetClass = 'gs-id-' + GridStackEngine._idSeq++;\r\n    this.el.classList.add(this._styleSheetClass);\r\n\r\n    this._setStaticClass();\r\n\r\n    let engineClass = opts.engineClass || GridStack.engineClass || GridStackEngine;\r\n    this.engine = new engineClass({\r\n      column: this.getColumn(),\r\n      float: opts.float,\r\n      maxRow: opts.maxRow,\r\n      onChange: (cbNodes) => {\r\n        let maxH = 0;\r\n        this.engine.nodes.forEach(n => { maxH = Math.max(maxH, n.y + n.h) });\r\n        cbNodes.forEach(n => {\r\n          let el = n.el;\r\n          if (!el) return;\r\n          if (n._removeDOM) {\r\n            if (el) el.remove();\r\n            delete n._removeDOM;\r\n          } else {\r\n            this._writePosAttr(el, n);\r\n          }\r\n        });\r\n        this._updateStyles(false, maxH); // false = don't recreate, just append if need be\r\n      }\r\n    });\r\n\r\n    // create initial global styles BEFORE loading children so resizeToContent margin can be calculated correctly\r\n    this._updateStyles(false, 0);\r\n\r\n    if (opts.auto) {\r\n      this.batchUpdate(); // prevent in between re-layout #1535 TODO: this only set float=true, need to prevent collision check...\r\n      this.engine._loading = true; // loading collision check\r\n      this.getGridItems().forEach(el => this._prepareElement(el));\r\n      delete this.engine._loading;\r\n      this.batchUpdate(false);\r\n    }\r\n\r\n    // load any passed in children as well, which overrides any DOM layout done above\r\n    if (opts.children) {\r\n      const children = opts.children;\r\n      delete opts.children;\r\n      if (children.length) this.load(children); // don't load empty\r\n    }\r\n\r\n    // if (this.engine.nodes.length) this._updateStyles(); // update based on # of children. done in engine onChange CB\r\n    this.setAnimation();\r\n\r\n    // dynamic grids require pausing during drag to detect over to nest vs push\r\n    if (opts.subGridDynamic && !DDManager.pauseDrag) DDManager.pauseDrag = true;\r\n    if (opts.draggable?.pause !== undefined) DDManager.pauseDrag = opts.draggable.pause;\r\n\r\n    this._setupRemoveDrop();\r\n    this._setupAcceptWidget();\r\n    this._updateResizeEvent();\r\n  }\r\n\r\n  /**\r\n   * add a new widget and returns it.\r\n   *\r\n   * Widget will be always placed even if result height is more than actual grid height.\r\n   * You need to use `willItFit()` before calling addWidget for additional check.\r\n   * See also `makeWidget()`.\r\n   *\r\n   * @example\r\n   * let grid = GridStack.init();\r\n   * grid.addWidget({w: 3, content: 'hello'});\r\n   * grid.addWidget('<div class=\"grid-stack-item\"><div class=\"grid-stack-item-content\">hello</div></div>', {w: 3});\r\n   *\r\n   * @param el  GridStackWidget (which can have content string as well), html element, or string definition to add\r\n   * @param options widget position/size options (optional, and ignore if first param is already option) - see GridStackWidget\r\n   */\r\n  public addWidget(els?: GridStackWidget | GridStackElement, options?: GridStackWidget): GridItemHTMLElement {\r\n    function isGridStackWidget(w: GridStackNode): w is GridStackNode { // https://medium.com/ovrsea/checking-the-type-of-an-object-in-typescript-the-type-guards-24d98d9119b0\r\n      return w.el !== undefined || w.x !== undefined || w.y !== undefined || w.w !== undefined || w.h !== undefined || w.content !== undefined ? true : false;\r\n    }\r\n\r\n    let el: GridItemHTMLElement;\r\n    let node: GridStackNode;\r\n    if (typeof els === 'string') {\r\n      let doc = document.implementation.createHTMLDocument(''); // IE needs a param\r\n      doc.body.innerHTML = els;\r\n      el = doc.body.children[0] as HTMLElement;\r\n    } else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {\r\n      node = options = els;\r\n      if (node?.el) {\r\n        el = node.el; // re-use element stored in the node\r\n      } else if (GridStack.addRemoveCB) {\r\n        el = GridStack.addRemoveCB(this.el, options, true, false);\r\n      } else {\r\n        let content = options?.content || '';\r\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\r\n        doc.body.innerHTML = `<div class=\"grid-stack-item ${this.opts.itemClass || ''}\"><div class=\"grid-stack-item-content\">${content}</div></div>`;\r\n        el = doc.body.children[0] as HTMLElement;\r\n      }\r\n    } else {\r\n      el = els as HTMLElement;\r\n    }\r\n\r\n    if (!el) return;\r\n\r\n    // if the caller ended up initializing the widget in addRemoveCB, or we stared with one already, skip the rest\r\n    node = el.gridstackNode;\r\n    if (node && el.parentElement === this.el && this.engine.nodes.find(n => n._id === node._id)) return el;\r\n\r\n    // Tempting to initialize the passed in opt with default and valid values, but this break knockout demos\r\n    // as the actual value are filled in when _prepareElement() calls el.getAttribute('gs-xyz') before adding the node.\r\n    // So make sure we load any DOM attributes that are not specified in passed in options (which override)\r\n    let domAttr = this._readAttr(el);\r\n    options = Utils.cloneDeep(options) || {};  // make a copy before we modify in case caller re-uses it\r\n    Utils.defaults(options, domAttr);\r\n    node = this.engine.prepareNode(options);\r\n    this._writeAttr(el, options);\r\n\r\n    this.el.appendChild(el);\r\n\r\n    this.makeWidget(el, options);\r\n\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Convert an existing gridItem element into a sub-grid with the given (optional) options, else inherit them\r\n   * from the parent's subGrid options.\r\n   * @param el gridItem element to convert\r\n   * @param ops (optional) sub-grid options, else default to node, then parent settings, else defaults\r\n   * @param nodeToAdd (optional) node to add to the newly created sub grid (used when dragging over existing regular item)\r\n   * @param saveContent if true (default) the html inside .grid-stack-content will be saved to child widget\r\n   * @returns newly created grid\r\n   */\r\n  public makeSubGrid(el: GridItemHTMLElement, ops?: GridStackOptions, nodeToAdd?: GridStackNode, saveContent = true): GridStack {\r\n    let node = el.gridstackNode;\r\n    if (!node) {\r\n      node = this.makeWidget(el).gridstackNode;\r\n    }\r\n    if (node.subGrid?.el) return node.subGrid; // already done\r\n\r\n    // find the template subGrid stored on a parent as fallback...\r\n    let subGridTemplate: GridStackOptions; // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    let grid: GridStack = this;\r\n    while (grid && !subGridTemplate) {\r\n      subGridTemplate = grid.opts?.subGridOpts;\r\n      grid = grid.parentGridItem?.grid;\r\n    }\r\n    //... and set the create options\r\n    ops = Utils.cloneDeep({ ...(subGridTemplate || {}), children: undefined, ...(ops || node.subGridOpts || {}) });\r\n    node.subGridOpts = ops;\r\n\r\n    // if column special case it set, remember that flag and set default\r\n    let autoColumn: boolean;\r\n    if (ops.column === 'auto') {\r\n      autoColumn = true;\r\n      ops.column = Math.max(node.w || 1, nodeToAdd?.w || 1);\r\n      delete ops.columnOpts; // driven by parent\r\n    }\r\n\r\n    // if we're converting an existing full item, move over the content to be the first sub item in the new grid\r\n    let content = node.el.querySelector('.grid-stack-item-content') as HTMLElement;\r\n    let newItem: HTMLElement;\r\n    let newItemOpt: GridStackNode;\r\n    if (saveContent) {\r\n      this._removeDD(node.el); // remove D&D since it's set on content div\r\n      newItemOpt = { ...node, x: 0, y: 0 };\r\n      Utils.removeInternalForSave(newItemOpt);\r\n      delete newItemOpt.subGridOpts;\r\n      if (node.content) {\r\n        newItemOpt.content = node.content;\r\n        delete node.content;\r\n      }\r\n      if (GridStack.addRemoveCB) {\r\n        newItem = GridStack.addRemoveCB(this.el, newItemOpt, true, false);\r\n      } else {\r\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\r\n        doc.body.innerHTML = `<div class=\"grid-stack-item\"></div>`;\r\n        newItem = doc.body.children[0] as HTMLElement;\r\n        newItem.appendChild(content);\r\n        doc.body.innerHTML = `<div class=\"grid-stack-item-content\"></div>`;\r\n        content = doc.body.children[0] as HTMLElement;\r\n        node.el.appendChild(content);\r\n      }\r\n      this._prepareDragDropByNode(node); // ... and restore original D&D\r\n    }\r\n\r\n    // if we're adding an additional item, make the container large enough to have them both\r\n    if (nodeToAdd) {\r\n      let w = autoColumn ? ops.column : node.w;\r\n      let h = node.h + nodeToAdd.h;\r\n      let style = node.el.style;\r\n      style.transition = 'none'; // show up instantly so we don't see scrollbar with nodeToAdd\r\n      this.update(node.el, { w, h });\r\n      setTimeout(() => style.transition = null); // recover animation\r\n    }\r\n\r\n    let subGrid = node.subGrid = GridStack.addGrid(content, ops);\r\n    if (nodeToAdd?._moving) subGrid._isTemp = true; // prevent re-nesting as we add over\r\n    if (autoColumn) subGrid._autoColumn = true;\r\n\r\n    // add the original content back as a child of hte newly created grid\r\n    if (saveContent) {\r\n      subGrid.addWidget(newItem, newItemOpt);\r\n    }\r\n\r\n    // now add any additional node\r\n    if (nodeToAdd) {\r\n      if (nodeToAdd._moving) {\r\n        // create an artificial event even for the just created grid to receive this item\r\n        window.setTimeout(() => Utils.simulateMouseEvent(nodeToAdd._event, 'mouseenter', subGrid.el), 0);\r\n      } else {\r\n        subGrid.addWidget(node.el, node);\r\n      }\r\n    }\r\n    return subGrid;\r\n  }\r\n\r\n  /**\r\n   * called when an item was converted into a nested grid to accommodate a dragged over item, but then item leaves - return back\r\n   * to the original grid-item. Also called to remove empty sub-grids when last item is dragged out (since re-creating is simple)\r\n   */\r\n  public removeAsSubGrid(nodeThatRemoved?: GridStackNode): void {\r\n    let pGrid = this.parentGridItem?.grid;\r\n    if (!pGrid) return;\r\n\r\n    pGrid.batchUpdate();\r\n    pGrid.removeWidget(this.parentGridItem.el, true, true);\r\n    this.engine.nodes.forEach(n => {\r\n      // migrate any children over and offsetting by our location\r\n      n.x += this.parentGridItem.x;\r\n      n.y += this.parentGridItem.y;\r\n      pGrid.addWidget(n.el, n);\r\n    });\r\n    pGrid.batchUpdate(false);\r\n    if (this.parentGridItem) delete this.parentGridItem.subGrid;\r\n    delete this.parentGridItem;\r\n\r\n    // create an artificial event for the original grid now that this one is gone (got a leave, but won't get enter)\r\n    if (nodeThatRemoved) {\r\n      window.setTimeout(() => Utils.simulateMouseEvent(nodeThatRemoved._event, 'mouseenter', pGrid.el), 0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * saves the current layout returning a list of widgets for serialization which might include any nested grids.\r\n   * @param saveContent if true (default) the latest html inside .grid-stack-content will be saved to GridStackWidget.content field, else it will\r\n   * be removed.\r\n   * @param saveGridOpt if true (default false), save the grid options itself, so you can call the new GridStack.addGrid()\r\n   * to recreate everything from scratch. GridStackOptions.children would then contain the widget list instead.\r\n   * @param saveCB callback for each node -> widget, so application can insert additional data to be saved into the widget data structure.\r\n   * @returns list of widgets or full grid option, including .children list of widgets\r\n   */\r\n  public save(saveContent = true, saveGridOpt = false, saveCB = GridStack.saveCB): GridStackWidget[] | GridStackOptions {\r\n    // return copied GridStackWidget (with optionally .el) we can modify at will...\r\n    let list = this.engine.save(saveContent, saveCB);\r\n\r\n    // check for HTML content and nested grids\r\n    list.forEach(n => {\r\n      if (saveContent && n.el && !n.subGrid && !saveCB) { // sub-grid are saved differently, not plain content\r\n        let sub = n.el.querySelector('.grid-stack-item-content');\r\n        n.content = sub ? sub.innerHTML : undefined;\r\n        if (!n.content) delete n.content;\r\n      } else {\r\n        if (!saveContent && !saveCB) { delete n.content; }\r\n        // check for nested grid\r\n        if (n.subGrid?.el) {\r\n          const listOrOpt = n.subGrid.save(saveContent, saveGridOpt, saveCB);\r\n          n.subGridOpts = (saveGridOpt ? listOrOpt : { children: listOrOpt }) as GridStackOptions;\r\n          delete n.subGrid;\r\n        }\r\n      }\r\n      delete n.el;\r\n    });\r\n\r\n    // check if save entire grid options (needed for recursive) + children...\r\n    if (saveGridOpt) {\r\n      let o: InternalGridStackOptions = Utils.cloneDeep(this.opts);\r\n      // delete default values that will be recreated on launch\r\n      if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {\r\n        o.margin = o.marginTop;\r\n        delete o.marginTop; delete o.marginRight; delete o.marginBottom; delete o.marginLeft;\r\n      }\r\n      if (o.rtl === (this.el.style.direction === 'rtl')) { o.rtl = 'auto' }\r\n      if (this._isAutoCellHeight) {\r\n        o.cellHeight = 'auto'\r\n      }\r\n      if (this._autoColumn) {\r\n        o.column = 'auto';\r\n      }\r\n      const origShow = o._alwaysShowResizeHandle;\r\n      delete o._alwaysShowResizeHandle;\r\n      if (origShow !== undefined) {\r\n        o.alwaysShowResizeHandle = origShow;\r\n      } else {\r\n        delete o.alwaysShowResizeHandle;\r\n      }\r\n      Utils.removeInternalAndSame(o, gridDefaults);\r\n      o.children = list;\r\n      return o;\r\n    }\r\n\r\n    return list;\r\n  }\r\n\r\n  /**\r\n   * load the widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.\r\n   *\r\n   * @param layout list of widgets definition to update/create\r\n   * @param addAndRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving\r\n   * the user control of insertion.\r\n   *\r\n   * @example\r\n   * see http://gridstackjs.com/demo/serialization.html\r\n   */\r\n  public load(items: GridStackWidget[], addRemove: boolean | AddRemoveFcn = GridStack.addRemoveCB || true): GridStack {\r\n    items = Utils.cloneDeep(items); // so we can mod\r\n    const column = this.getColumn();\r\n\r\n    // make sure size 1x1 (default) is present as it may need to override current sizes\r\n    items.forEach(n => { n.w = n.w || 1; n.h = n.h || 1 });\r\n\r\n    // sort items. those without coord will be appended last\r\n    items = Utils.sort(items);\r\n\r\n    // if we're loading a layout into for example 1 column and items don't fit, make sure to save\r\n    // the original wanted layout so we can scale back up correctly #1471\r\n    let maxColumn = 0;\r\n    items.forEach(n => { maxColumn = Math.max(maxColumn, (n.x || 0) + n.w) });\r\n    if (maxColumn > column) {\r\n      this._ignoreLayoutsNodeChange = true; // skip layout update\r\n      this.engine.cacheLayout(items, maxColumn, true);\r\n    }\r\n\r\n    // if given a different callback, temporally set it as global option so creating will use it\r\n    const prevCB = GridStack.addRemoveCB;\r\n    if (typeof (addRemove) === 'function') GridStack.addRemoveCB = addRemove as AddRemoveFcn;\r\n\r\n    let removed: GridStackNode[] = [];\r\n    this.batchUpdate();\r\n\r\n    // if we are loading from empty temporarily remove animation\r\n    const blank = !this.engine.nodes.length;\r\n    if (blank) this.setAnimation(false);\r\n\r\n    // see if any items are missing from new layout and need to be removed first\r\n    if (!blank && addRemove) {\r\n      let copyNodes = [...this.engine.nodes]; // don't loop through array you modify\r\n      copyNodes.forEach(n => {\r\n        if (!n.id) return;\r\n        let item = Utils.find(items, n.id);\r\n        if (!item) {\r\n          if (GridStack.addRemoveCB) GridStack.addRemoveCB(this.el, n, false, false);\r\n          removed.push(n); // batch keep track\r\n          this.removeWidget(n.el, true, false);\r\n        }\r\n      });\r\n    }\r\n\r\n    // now add/update the widgets - starting with removing items in the new layout we will reposition\r\n    // to reduce collision and add no-coord ones at next available spot\r\n    this.engine._loading = true; // help with collision\r\n    let updateNodes: GridStackWidget[] = [];\r\n    this.engine.nodes = this.engine.nodes.filter(n => {\r\n      if (Utils.find(items, n.id)) { updateNodes.push(n); return false; } // remove if found from list\r\n      return true;\r\n    });\r\n    items.forEach(w => {\r\n      let item = Utils.find(updateNodes, w.id);\r\n      if (item) {\r\n        // if item sizes to content, re-use the exiting height so it's a better guess at the final size (same if width doesn't change)\r\n        if (Utils.shouldSizeToContent(item)) w.h = item.h;\r\n        // check if missing coord, in which case find next empty slot with new (or old if missing) sizes\r\n        this.engine.nodeBoundFix(w);\r\n        if (w.autoPosition || w.x === undefined || w.y === undefined) {\r\n          w.w = w.w || item.w;\r\n          w.h = w.h || item.h;\r\n          this.engine.findEmptyPosition(w);\r\n        }\r\n\r\n        // add back to current list BUT force a collision check if it 'appears' we didn't change to make sure we don't overlap others now\r\n        this.engine.nodes.push(item);\r\n        if (Utils.samePos(item, w)) {\r\n          this.moveNode(item, { ...w, forceCollide: true });\r\n        }\r\n\r\n        this.update(item.el, w);\r\n        if (w.subGridOpts?.children) { // update any sub grid as well\r\n          let sub = item.el.querySelector('.grid-stack') as GridHTMLElement;\r\n          if (sub && sub.gridstack) {\r\n            sub.gridstack.load(w.subGridOpts.children); // TODO: support updating grid options ?\r\n          }\r\n        }\r\n      } else if (addRemove) {\r\n        this.addWidget(w);\r\n      }\r\n    });\r\n\r\n    delete this.engine._loading; // done loading\r\n    this.engine.removedNodes = removed;\r\n    this.batchUpdate(false);\r\n\r\n    // after commit, clear that flag\r\n    delete this._ignoreLayoutsNodeChange;\r\n    prevCB ? GridStack.addRemoveCB = prevCB : delete GridStack.addRemoveCB;\r\n    // delay adding animation back\r\n    if (blank && this.opts?.animate) this.setAnimation(this.opts.animate, true);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * use before calling a bunch of `addWidget()` to prevent un-necessary relayouts in between (more efficient)\r\n   * and get a single event callback. You will see no changes until `batchUpdate(false)` is called.\r\n   */\r\n  public batchUpdate(flag = true): GridStack {\r\n    this.engine.batchUpdate(flag);\r\n    if (!flag) {\r\n      this._updateContainerHeight();\r\n      this._triggerRemoveEvent();\r\n      this._triggerAddEvent();\r\n      this._triggerChangeEvent();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Gets current cell height.\r\n   */\r\n  public getCellHeight(forcePixel = false): number {\r\n    if (this.opts.cellHeight && this.opts.cellHeight !== 'auto' &&\r\n      (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === 'px')) {\r\n      return this.opts.cellHeight as number;\r\n    }\r\n    // do rem/em/cm/mm to px conversion\r\n    if (this.opts.cellHeightUnit === 'rem') {\r\n      return (this.opts.cellHeight as number) * parseFloat(getComputedStyle(document.documentElement).fontSize);\r\n    }\r\n    if (this.opts.cellHeightUnit === 'em') {\r\n      return (this.opts.cellHeight as number) * parseFloat(getComputedStyle(this.el).fontSize);\r\n    }\r\n    if (this.opts.cellHeightUnit === 'cm') {\r\n      // 1cm = 96px/2.54. See https://www.w3.org/TR/css-values-3/#absolute-lengths\r\n      return (this.opts.cellHeight as number) * (96 / 2.54);\r\n    }\r\n    if (this.opts.cellHeightUnit === 'mm') {\r\n      return (this.opts.cellHeight as number) * (96 / 2.54) / 10;\r\n    }\r\n    // else get first cell height\r\n    let el = this.el.querySelector('.' + this.opts.itemClass) as HTMLElement;\r\n    if (el) {\r\n      let h = Utils.toNumber(el.getAttribute('gs-h')) || 1; // since we don't write 1 anymore\r\n      return Math.round(el.offsetHeight / h);\r\n    }\r\n    // else do entire grid and # of rows (but doesn't work if min-height is the actual constrain)\r\n    let rows = parseInt(this.el.getAttribute('gs-current-row'));\r\n    return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight as number;\r\n  }\r\n\r\n  /**\r\n   * Update current cell height - see `GridStackOptions.cellHeight` for format.\r\n   * This method rebuilds an internal CSS style sheet.\r\n   * Note: You can expect performance issues if call this method too often.\r\n   *\r\n   * @param val the cell height. If not passed (undefined), cells content will be made square (match width minus margin),\r\n   * if pass 0 the CSS will be generated by the application instead.\r\n   * @param update (Optional) if false, styles will not be updated\r\n   *\r\n   * @example\r\n   * grid.cellHeight(100); // same as 100px\r\n   * grid.cellHeight('70px');\r\n   * grid.cellHeight(grid.cellWidth() * 1.2);\r\n   */\r\n  public cellHeight(val?: numberOrString, update = true): GridStack {\r\n\r\n    // if not called internally, check if we're changing mode\r\n    if (update && val !== undefined) {\r\n      if (this._isAutoCellHeight !== (val === 'auto')) {\r\n        this._isAutoCellHeight = (val === 'auto');\r\n        this._updateResizeEvent();\r\n      }\r\n    }\r\n    if (val === 'initial' || val === 'auto') { val = undefined; }\r\n\r\n    // make item content be square\r\n    if (val === undefined) {\r\n      let marginDiff = - (this.opts.marginRight as number) - (this.opts.marginLeft as number)\r\n        + (this.opts.marginTop as number) + (this.opts.marginBottom as number);\r\n      val = this.cellWidth() + marginDiff;\r\n    }\r\n\r\n    let data = Utils.parseHeight(val);\r\n    if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {\r\n      return this;\r\n    }\r\n    this.opts.cellHeightUnit = data.unit;\r\n    this.opts.cellHeight = data.h;\r\n\r\n    this.resizeToContentCheck();\r\n\r\n    if (update) {\r\n      this._updateStyles(true); // true = force re-create for current # of rows\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** Gets current cell width. */\r\n  public cellWidth(): number {\r\n    return this._widthOrContainer() / this.getColumn();\r\n  }\r\n  /** return our expected width (or parent) , and optionally of window for dynamic column check */\r\n  protected _widthOrContainer(forBreakpoint = false): number {\r\n    // use `offsetWidth` or `clientWidth` (no scrollbar) ?\r\n    // https://stackoverflow.com/questions/21064101/understanding-offsetwidth-clientwidth-scrollwidth-and-height-respectively\r\n    return forBreakpoint && this.opts.columnOpts?.breakpointForWindow ? window.innerWidth : (this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth);\r\n  }\r\n  /** checks for dynamic column count for our current size, returning true if changed */\r\n  protected checkDynamicColumn(): boolean {\r\n    const resp = this.opts.columnOpts;\r\n    if (!resp || (!resp.columnWidth && !resp.breakpoints?.length)) return false;\r\n    const column = this.getColumn();\r\n    let newColumn = column;\r\n    const w = this._widthOrContainer(true);\r\n    if (resp.columnWidth) {\r\n      newColumn = Math.min(Math.round(w / resp.columnWidth) || 1, resp.columnMax);\r\n    } else {\r\n      // find the closest breakpoint (already sorted big to small) that matches\r\n      newColumn = resp.columnMax;\r\n      let i = 0;\r\n      while (i < resp.breakpoints.length && w <= resp.breakpoints[i].w) {\r\n        newColumn = resp.breakpoints[i++].c || column;\r\n      }\r\n    }\r\n    if (newColumn !== column) {\r\n      const bk = resp.breakpoints?.find(b => b.c === newColumn);\r\n      this.column(newColumn, bk?.layout || resp.layout);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * re-layout grid items to reclaim any empty space. Options are:\r\n   * 'list' keep the widget left->right order the same, even if that means leaving an empty slot if things don't fit\r\n   * 'compact' might re-order items to fill any empty space\r\n   *\r\n   * doSort - 'false' to let you do your own sorting ahead in case you need to control a different order. (default to sort)\r\n   */\r\n  public compact(layout: CompactOptions = 'compact', doSort = true): GridStack {\r\n    this.engine.compact(layout, doSort);\r\n    this._triggerChangeEvent();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * set the number of columns in the grid. Will update existing widgets to conform to new number of columns,\r\n   * as well as cache the original layout so you can revert back to previous positions without loss.\r\n   * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11],\r\n   * else you will need to generate correct CSS (see https://github.com/gridstack/gridstack.js#change-grid-columns)\r\n   * @param column - Integer > 0 (default 12).\r\n   * @param layout specify the type of re-layout that will happen (position, size, etc...).\r\n   * Note: items will never be outside of the current column boundaries. default ('moveScale'). Ignored for 1 column\r\n   */\r\n  public column(column: number, layout: ColumnOptions = 'moveScale'): GridStack {\r\n    if (!column || column < 1 || this.opts.column === column) return this;\r\n\r\n    let oldColumn = this.getColumn();\r\n    this.opts.column = column;\r\n    if (!this.engine) return this; // called in constructor, noting else to do\r\n\r\n    this.engine.column = column;\r\n    this.el.classList.remove('gs-' + oldColumn);\r\n    this.el.classList.add('gs-' + column);\r\n\r\n    // update the items now, checking if we have a custom children layout\r\n    /*const newChildren = this.opts.columnOpts?.breakpoints?.find(r => r.c === column)?.children;\r\n    if (newChildren) this.load(newChildren);\r\n    else*/ this.engine.columnChanged(oldColumn, column, layout);\r\n    if (this._isAutoCellHeight) this.cellHeight();\r\n\r\n    this.resizeToContentCheck(true); // wait for width resizing\r\n\r\n    // and trigger our event last...\r\n    this._ignoreLayoutsNodeChange = true; // skip layout update\r\n    this._triggerChangeEvent();\r\n    delete this._ignoreLayoutsNodeChange;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * get the number of columns in the grid (default 12)\r\n   */\r\n  public getColumn(): number { return this.opts.column as number; }\r\n\r\n  /** returns an array of grid HTML elements (no placeholder) - used to iterate through our children in DOM order */\r\n  public getGridItems(): GridItemHTMLElement[] {\r\n    return Array.from(this.el.children)\r\n      .filter((el: HTMLElement) => el.matches('.' + this.opts.itemClass) && !el.matches('.' + this.opts.placeholderClass)) as GridItemHTMLElement[];\r\n  }\r\n\r\n  /**\r\n   * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.\r\n   * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).\r\n   */\r\n  public destroy(removeDOM = true): GridStack {\r\n    if (!this.el) return; // prevent multiple calls\r\n    this.offAll();\r\n    this._updateResizeEvent(true);\r\n    this.setStatic(true, false); // permanently removes DD but don't set CSS class (we're going away)\r\n    this.setAnimation(false);\r\n    if (!removeDOM) {\r\n      this.removeAll(removeDOM);\r\n      this.el.classList.remove(this._styleSheetClass);\r\n      this.el.removeAttribute('gs-current-row');\r\n    } else {\r\n      this.el.parentNode.removeChild(this.el);\r\n    }\r\n    this._removeStylesheet();\r\n    if (this.parentGridItem) delete this.parentGridItem.subGrid;\r\n    delete this.parentGridItem;\r\n    delete this.opts;\r\n    delete this._placeholder;\r\n    delete this.engine;\r\n    delete this.el.gridstack; // remove circular dependency that would prevent a freeing\r\n    delete this.el;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html)\r\n   */\r\n  public float(val: boolean): GridStack {\r\n    if (this.opts.float !== val) {\r\n      this.opts.float = this.engine.float = val;\r\n      this._triggerChangeEvent();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * get the current float mode\r\n   */\r\n  public getFloat(): boolean {\r\n    return this.engine.float;\r\n  }\r\n\r\n  /**\r\n   * Get the position of the cell under a pixel on screen.\r\n   * @param position the position of the pixel to resolve in\r\n   * absolute coordinates, as an object with top and left properties\r\n   * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).\r\n   * Useful when grid is within `position: relative` element\r\n   *\r\n   * Returns an object with properties `x` and `y` i.e. the column and row in the grid.\r\n   */\r\n  public getCellFromPixel(position: MousePosition, useDocRelative = false): CellPosition {\r\n    let box = this.el.getBoundingClientRect();\r\n    // console.log(`getBoundingClientRect left: ${box.left} top: ${box.top} w: ${box.w} h: ${box.h}`)\r\n    let containerPos: { top: number, left: number };\r\n    if (useDocRelative) {\r\n      containerPos = { top: box.top + document.documentElement.scrollTop, left: box.left };\r\n      // console.log(`getCellFromPixel scrollTop: ${document.documentElement.scrollTop}`)\r\n    } else {\r\n      containerPos = { top: this.el.offsetTop, left: this.el.offsetLeft }\r\n      // console.log(`getCellFromPixel offsetTop: ${containerPos.left} offsetLeft: ${containerPos.top}`)\r\n    }\r\n    let relativeLeft = position.left - containerPos.left;\r\n    let relativeTop = position.top - containerPos.top;\r\n\r\n    let columnWidth = (box.width / this.getColumn());\r\n    let rowHeight = (box.height / parseInt(this.el.getAttribute('gs-current-row')));\r\n\r\n    return { x: Math.floor(relativeLeft / columnWidth), y: Math.floor(relativeTop / rowHeight) };\r\n  }\r\n\r\n  /** returns the current number of rows, which will be at least `minRow` if set */\r\n  public getRow(): number {\r\n    return Math.max(this.engine.getRow(), this.opts.minRow);\r\n  }\r\n\r\n  /**\r\n   * Checks if specified area is empty.\r\n   * @param x the position x.\r\n   * @param y the position y.\r\n   * @param w the width of to check\r\n   * @param h the height of to check\r\n   */\r\n  public isAreaEmpty(x: number, y: number, w: number, h: number): boolean {\r\n    return this.engine.isAreaEmpty(x, y, w, h);\r\n  }\r\n\r\n  /**\r\n   * If you add elements to your grid by hand (or have some framework creating DOM), you have to tell gridstack afterwards to make them widgets.\r\n   * If you want gridstack to add the elements for you, use `addWidget()` instead.\r\n   * Makes the given element a widget and returns it.\r\n   * @param els widget or single selector to convert.\r\n   * @param options widget definition to use instead of reading attributes or using default sizing values\r\n   *\r\n   * @example\r\n   * let grid = GridStack.init();\r\n   * grid.el.appendChild('<div id=\"1\" gs-w=\"3\"></div>');\r\n   * grid.el.appendChild('<div id=\"2\"></div>');\r\n   * grid.makeWidget('1');\r\n   * grid.makeWidget('2', {w:2, content: 'hello'});\r\n   */\r\n  public makeWidget(els: GridStackElement, options?: GridStackWidget): GridItemHTMLElement {\r\n    let el = GridStack.getElement(els);\r\n    this._prepareElement(el, true, options);\r\n    const node = el.gridstackNode;\r\n\r\n    this._updateContainerHeight();\r\n\r\n    // see if there is a sub-grid to create\r\n    if (node.subGridOpts) {\r\n      this.makeSubGrid(el, node.subGridOpts, undefined, false); // node.subGrid will be used as option in method, no need to pass\r\n    }\r\n\r\n    // if we're adding an item into 1 column make sure\r\n    // we don't override the larger 12 column layout that was already saved. #1985\r\n    if (this.opts.column === 1) {\r\n      this._ignoreLayoutsNodeChange = true;\r\n    }\r\n    this._triggerAddEvent();\r\n    this._triggerChangeEvent();\r\n    delete this._ignoreLayoutsNodeChange;\r\n\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Event handler that extracts our CustomEvent data out automatically for receiving custom\r\n   * notifications (see doc for supported events)\r\n   * @param name of the event (see possible values) or list of names space separated\r\n   * @param callback function called with event and optional second/third param\r\n   * (see README documentation for each signature).\r\n   *\r\n   * @example\r\n   * grid.on('added', function(e, items) { log('added ', items)} );\r\n   * or\r\n   * grid.on('added removed change', function(e, items) { log(e.type, items)} );\r\n   *\r\n   * Note: in some cases it is the same as calling native handler and parsing the event.\r\n   * grid.el.addEventListener('added', function(event) { log('added ', event.detail)} );\r\n   *\r\n   */\r\n  public on(name: 'dropped', callback: GridStackDroppedHandler): GridStack\r\n  public on(name: 'enable' | 'disable', callback: GridStackEventHandler): GridStack\r\n  public on(name: 'change' | 'added' | 'removed' | 'resizecontent', callback: GridStackNodesHandler): GridStack\r\n  public on(name: 'resizestart' | 'resize' | 'resizestop' | 'dragstart' | 'drag' | 'dragstop', callback: GridStackElementHandler): GridStack\r\n  public on(name: string, callback: GridStackEventHandlerCallback): GridStack\r\n  public on(name: GridStackEvent | string, callback: GridStackEventHandlerCallback): GridStack {\r\n    // check for array of names being passed instead\r\n    if (name.indexOf(' ') !== -1) {\r\n      let names = name.split(' ') as GridStackEvent[];\r\n      names.forEach(name => this.on(name, callback));\r\n      return this;\r\n    }\r\n\r\n    // native CustomEvent handlers - cash the generic handlers so we can easily remove\r\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\r\n      let noData = (name === 'enable' || name === 'disable');\r\n      if (noData) {\r\n        this._gsEventHandler[name] = (event: Event) => (callback as GridStackEventHandler)(event);\r\n      } else {\r\n        this._gsEventHandler[name] = (event: CustomEvent) => (callback as GridStackNodesHandler)(event, event.detail);\r\n      }\r\n      this.el.addEventListener(name, this._gsEventHandler[name]);\r\n    } else if (name === 'drag' || name === 'dragstart' || name === 'dragstop' || name === 'resizestart' || name === 'resize'\r\n      || name === 'resizestop' || name === 'dropped' || name === 'resizecontent') {\r\n      // drag&drop stop events NEED to be call them AFTER we update node attributes so handle them ourself.\r\n      // do same for start event to make it easier...\r\n      this._gsEventHandler[name] = callback;\r\n    } else {\r\n      console.error('GridStack.on(' + name + ') event not supported');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * unsubscribe from the 'on' event GridStackEvent\r\n   * @param name of the event (see possible values) or list of names space separated\r\n   */\r\n  public off(name: GridStackEvent | string): GridStack {\r\n    // check for array of names being passed instead\r\n    if (name.indexOf(' ') !== -1) {\r\n      let names = name.split(' ') as GridStackEvent[];\r\n      names.forEach(name => this.off(name));\r\n      return this;\r\n    }\r\n\r\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\r\n      // remove native CustomEvent handlers\r\n      if (this._gsEventHandler[name]) {\r\n        this.el.removeEventListener(name, this._gsEventHandler[name]);\r\n      }\r\n    }\r\n    delete this._gsEventHandler[name];\r\n\r\n    return this;\r\n  }\r\n\r\n  /** remove all event handlers */\r\n  public offAll(): GridStack {\r\n    Object.keys(this._gsEventHandler).forEach((key: GridStackEvent) => this.off(key));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes widget from the grid.\r\n   * @param el  widget or selector to modify\r\n   * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).\r\n   * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\r\n   */\r\n  public removeWidget(els: GridStackElement, removeDOM = true, triggerEvent = true): GridStack {\r\n    GridStack.getElements(els).forEach(el => {\r\n      if (el.parentElement && el.parentElement !== this.el) return; // not our child!\r\n      let node = el.gridstackNode;\r\n      // For Meteor support: https://github.com/gridstack/gridstack.js/pull/272\r\n      if (!node) {\r\n        node = this.engine.nodes.find(n => el === n.el);\r\n      }\r\n      if (!node) return;\r\n\r\n      if (removeDOM && GridStack.addRemoveCB) {\r\n        GridStack.addRemoveCB(this.el, node, false, false);\r\n      }\r\n\r\n      // remove our DOM data (circular link) and drag&drop permanently\r\n      delete el.gridstackNode;\r\n      this._removeDD(el);\r\n\r\n      this.engine.removeNode(node, removeDOM, triggerEvent);\r\n\r\n      if (removeDOM && el.parentElement) {\r\n        el.remove(); // in batch mode engine.removeNode doesn't call back to remove DOM\r\n      }\r\n    });\r\n    if (triggerEvent) {\r\n      this._triggerRemoveEvent();\r\n      this._triggerChangeEvent();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes all widgets from the grid.\r\n   * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).\r\n   * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\r\n   */\r\n  public removeAll(removeDOM = true, triggerEvent = true): GridStack {\r\n    // always remove our DOM data (circular link) before list gets emptied and drag&drop permanently\r\n    this.engine.nodes.forEach(n => {\r\n      if (removeDOM && GridStack.addRemoveCB) {\r\n        GridStack.addRemoveCB(this.el, n, false, false);\r\n      }\r\n      delete n.el.gridstackNode;\r\n      if (!this.opts.staticGrid) this._removeDD(n.el);\r\n    });\r\n    this.engine.removeAll(removeDOM, triggerEvent);\r\n    if (triggerEvent) this._triggerRemoveEvent();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.\r\n   * @param doAnimate if true the grid will animate.\r\n   * @param delay if true setting will be set on next event loop.\r\n   */\r\n  public setAnimation(doAnimate = this.opts.animate, delay?: boolean): GridStack {\r\n    if (delay) {\r\n      // delay, but check to make sure grid (opt) is still around\r\n      setTimeout(() => { if (this.opts) this.setAnimation(doAnimate) });\r\n    } else if (doAnimate) {\r\n      this.el.classList.add('grid-stack-animate');\r\n    } else {\r\n      this.el.classList.remove('grid-stack-animate');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  private hasAnimationCSS(): boolean { return this.el.classList.contains('grid-stack-animate') }\r\n\r\n  /**\r\n   * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.\r\n   * Also toggle the grid-stack-static class.\r\n   * @param val if true the grid become static.\r\n   * @param updateClass true (default) if css class gets updated\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public setStatic(val: boolean, updateClass = true, recurse = true): GridStack {\r\n    if (!!this.opts.staticGrid === val) return this;\r\n    val ? this.opts.staticGrid = true : delete this.opts.staticGrid;\r\n    this._setupRemoveDrop();\r\n    this._setupAcceptWidget();\r\n    this.engine.nodes.forEach(n => {\r\n      this._prepareDragDropByNode(n); // either delete or init Drag&drop\r\n      if (n.subGrid && recurse) n.subGrid.setStatic(val, updateClass, recurse);\r\n    });\r\n    if (updateClass) { this._setStaticClass(); }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Updates widget position/size and other info. Note: if you need to call this on all nodes, use load() instead which will update what changed.\r\n   * @param els  widget or selector of objects to modify (note: setting the same x,y for multiple items will be indeterministic and likely unwanted)\r\n   * @param opt new widget options (x,y,w,h, etc..). Only those set will be updated.\r\n   */\r\n  public update(els: GridStackElement, opt: GridStackWidget): GridStack {\r\n\r\n    // support legacy call for now ?\r\n    if (arguments.length > 2) {\r\n      console.warn('gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update(el, {x, w, content, ...})`. It will be removed soon');\r\n      // eslint-disable-next-line prefer-rest-params\r\n      let a = arguments, i = 1;\r\n      opt = { x: a[i++], y: a[i++], w: a[i++], h: a[i++] };\r\n      return this.update(els, opt);\r\n    }\r\n\r\n    GridStack.getElements(els).forEach(el => {\r\n      let n = el?.gridstackNode;\r\n      if (!n) return;\r\n      let w = Utils.cloneDeep(opt); // make a copy we can modify in case they re-use it or multiple items\r\n      this.engine.nodeBoundFix(w);\r\n      delete w.autoPosition;\r\n      delete w.id;\r\n\r\n      // move/resize widget if anything changed\r\n      let keys = ['x', 'y', 'w', 'h'];\r\n      let m: GridStackWidget;\r\n      if (keys.some(k => w[k] !== undefined && w[k] !== n[k])) {\r\n        m = {};\r\n        keys.forEach(k => {\r\n          m[k] = (w[k] !== undefined) ? w[k] : n[k];\r\n          delete w[k];\r\n        });\r\n      }\r\n      // for a move as well IFF there is any min/max fields set\r\n      if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {\r\n        m = {}; // will use node position but validate values\r\n      }\r\n\r\n      // check for content changing\r\n      if (w.content !== undefined) {\r\n        const itemContent = el.querySelector('.grid-stack-item-content');\r\n        if (itemContent && itemContent.innerHTML !== w.content) {\r\n          itemContent.innerHTML = w.content;\r\n          // restore any sub-grid back\r\n          if (n.subGrid?.el) {\r\n            itemContent.appendChild(n.subGrid.el);\r\n            if (!n.subGrid.opts.styleInHead) n.subGrid._updateStyles(true); // force create\r\n          }\r\n        }\r\n        delete w.content;\r\n      }\r\n\r\n      // any remaining fields are assigned, but check for dragging changes, resize constrain\r\n      let changed = false;\r\n      let ddChanged = false;\r\n      for (const key in w) {\r\n        if (key[0] !== '_' && n[key] !== w[key]) {\r\n          n[key] = w[key];\r\n          changed = true;\r\n          ddChanged = ddChanged || (!this.opts.staticGrid && (key === 'noResize' || key === 'noMove' || key === 'locked'));\r\n        }\r\n      }\r\n      Utils.sanitizeMinMax(n);\r\n\r\n      // finally move the widget and update attr\r\n      if (m) {\r\n        const widthChanged = (m.w !== undefined && m.w !== n.w);\r\n        this.moveNode(n, m);\r\n        this.resizeToContentCheck(widthChanged, n); // wait for animation if we changed width\r\n        delete n._orig; // clear out original position now that we moved #2669\r\n      }\r\n      if (m || changed) {\r\n        this._writeAttr(el, n);\r\n      }\r\n      if (ddChanged) {\r\n        this._prepareDragDropByNode(n);\r\n      }\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  private moveNode(n: GridStackNode, m: GridStackMoveOpts) {\r\n    const wasUpdating = n._updating;\r\n    if (!wasUpdating) this.engine.cleanNodes().beginUpdate(n);\r\n    this.engine.moveNode(n, m);\r\n    this._updateContainerHeight();\r\n    if (!wasUpdating) {\r\n      this._triggerChangeEvent();\r\n      this.engine.endUpdate();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates widget height to match the content height to avoid v-scrollbar or dead space.\r\n   * Note: this assumes only 1 child under resizeToContentParent='.grid-stack-item-content' (sized to gridItem minus padding) that is at the entire content size wanted.\r\n   * @param el grid item element\r\n   * @param useNodeH set to true if GridStackNode.h should be used instead of actual container height when we don't need to wait for animation to finish to get actual DOM heights\r\n   */\r\n  public resizeToContent(el: GridItemHTMLElement) {\r\n    if (!el) return;\r\n    el.classList.remove('size-to-content-max');\r\n    if (!el.clientHeight) return; // 0 when hidden, skip\r\n    const n = el.gridstackNode;\r\n    if (!n) return;\r\n    const grid = n.grid;\r\n    if (!grid || el.parentElement !== grid.el) return; // skip if we are not inside a grid\r\n    const cell = grid.getCellHeight(true);\r\n    if (!cell) return;\r\n    let height = n.h ? n.h * cell : el.clientHeight; // getBoundingClientRect().height seem to flicker back and forth\r\n    let item: Element;\r\n    if (n.resizeToContentParent) item = el.querySelector(n.resizeToContentParent);\r\n    if (!item) item = el.querySelector(GridStack.resizeToContentParent);\r\n    if (!item) return;\r\n    const padding = el.clientHeight - item.clientHeight; // full - available height to our child (minus border, padding...)\r\n    const itemH = n.h ? n.h * cell - padding : item.clientHeight; // calculated to what cellHeight is or will become (rather than actual to prevent waiting for animation to finish)\r\n    let wantedH: number;\r\n    if (n.subGrid) {\r\n      // sub-grid - use their actual row count * their cell height\r\n      wantedH = n.subGrid.getRow() * n.subGrid.getCellHeight(true);\r\n    } else if (n.subGridOpts?.children?.length) {\r\n      // not sub-grid just yet (case above) wait until we do\r\n      return;\r\n    } else {\r\n      // NOTE: clientHeight & getBoundingClientRect() is undefined for text and other leaf nodes. use <div> container!\r\n      const child = item.firstElementChild;\r\n      if (!child) {\r\n        console.error(`Error: GridStack.resizeToContent() widget id:${n.id} '${GridStack.resizeToContentParent}'.firstElementChild is null, make sure to have a div like container. Skipping sizing.`);\r\n        return;\r\n      }\r\n      wantedH = child.getBoundingClientRect().height || itemH;\r\n    }\r\n    if (itemH === wantedH) return;\r\n    height += wantedH - itemH;\r\n    let h = Math.ceil(height / cell);\r\n    // check for min/max and special sizing\r\n    const softMax = Number.isInteger(n.sizeToContent) ? n.sizeToContent as number : 0;\r\n    if (softMax && h > softMax) {\r\n      h = softMax;\r\n      el.classList.add('size-to-content-max');  // get v-scroll back\r\n    }\r\n    if (n.minH && h < n.minH) h = n.minH;\r\n    else if (n.maxH && h > n.maxH) h = n.maxH;\r\n    if (h !== n.h) {\r\n      grid._ignoreLayoutsNodeChange = true;\r\n      grid.moveNode(n, { h });\r\n      delete grid._ignoreLayoutsNodeChange;\r\n    }\r\n  }\r\n\r\n  /** call the user resize (so they can do extra work) else our build in version */\r\n  private resizeToContentCBCheck(el: GridItemHTMLElement) {\r\n    if (GridStack.resizeToContentCB) GridStack.resizeToContentCB(el);\r\n    else this.resizeToContent(el);\r\n  }\r\n\r\n  /** rotate (by swapping w & h) the passed in node - called when user press 'r' during dragging\r\n   * @param els  widget or selector of objects to modify\r\n   * @param relative optional pixel coord relative to upper/left corner to rotate around (will keep that cell under cursor)\r\n   */\r\n  public rotate(els: GridStackElement, relative?: Position): GridStack {\r\n    GridStack.getElements(els).forEach(el => {\r\n      let n = el.gridstackNode;\r\n      if (!Utils.canBeRotated(n)) return;\r\n      const rot: GridStackWidget = { w: n.h, h: n.w, minH: n.minW, minW: n.minH, maxH: n.maxW, maxW: n.maxH };\r\n      // if given an offset, adjust x/y by column/row bounds when user presses 'r' during dragging\r\n      if (relative) {\r\n        let pivotX = relative.left > 0 ? Math.floor(relative.left / this.cellWidth()) : 0;\r\n        let pivotY = relative.top > 0 ? Math.floor(relative.top / (this.opts.cellHeight as number)) : 0;\r\n        rot.x = n.x + pivotX - (n.h - (pivotY+1));\r\n        rot.y = (n.y + pivotY) - pivotX;\r\n      }\r\n      Object.keys(rot).forEach(k => { if (rot[k] === undefined) delete rot[k]; });\r\n      const _orig = n._orig;\r\n      this.update(el, rot);\r\n      n._orig = _orig; // restore as move() will delete it\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options (CSS string format of 1,2,4 values or single number).\r\n   * @param value margin value\r\n   */\r\n  public margin(value: numberOrString): GridStack {\r\n    let isMultiValue = (typeof value === 'string' && value.split(' ').length > 1);\r\n    // check if we can skip re-creating our CSS file... won't check if multi values (too much hassle)\r\n    if (!isMultiValue) {\r\n      let data = Utils.parseHeight(value);\r\n      if (this.opts.marginUnit === data.unit && this.opts.margin === data.h) return;\r\n    }\r\n    // re-use existing margin handling\r\n    this.opts.margin = value;\r\n    this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = undefined;\r\n    this._initMargin();\r\n\r\n    this._updateStyles(true); // true = force re-create\r\n\r\n    return this;\r\n  }\r\n\r\n  /** returns current margin number value (undefined if 4 sides don't match) */\r\n  public getMargin(): number { return this.opts.margin as number; }\r\n\r\n  /**\r\n   * Returns true if the height of the grid will be less than the vertical\r\n   * constraint. Always returns true if grid doesn't have height constraint.\r\n   * @param node contains x,y,w,h,auto-position options\r\n   *\r\n   * @example\r\n   * if (grid.willItFit(newWidget)) {\r\n   *   grid.addWidget(newWidget);\r\n   * } else {\r\n   *   alert('Not enough free space to place the widget');\r\n   * }\r\n   */\r\n  public willItFit(node: GridStackWidget): boolean {\r\n    // support legacy call for now\r\n    if (arguments.length > 1) {\r\n      console.warn('gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon');\r\n      // eslint-disable-next-line prefer-rest-params\r\n      let a = arguments, i = 0,\r\n        w: GridStackWidget = { x: a[i++], y: a[i++], w: a[i++], h: a[i++], autoPosition: a[i++] };\r\n      return this.willItFit(w);\r\n    }\r\n    return this.engine.willItFit(node);\r\n  }\r\n\r\n  /** @internal */\r\n  protected _triggerChangeEvent(): GridStack {\r\n    if (this.engine.batchMode) return this;\r\n    let elements = this.engine.getDirtyNodes(true); // verify they really changed\r\n    if (elements && elements.length) {\r\n      if (!this._ignoreLayoutsNodeChange) {\r\n        this.engine.layoutsNodesChange(elements);\r\n      }\r\n      this._triggerEvent('change', elements);\r\n    }\r\n    this.engine.saveInitial(); // we called, now reset initial values & dirty flags\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _triggerAddEvent(): GridStack {\r\n    if (this.engine.batchMode) return this;\r\n    if (this.engine.addedNodes?.length) {\r\n      if (!this._ignoreLayoutsNodeChange) {\r\n        this.engine.layoutsNodesChange(this.engine.addedNodes);\r\n      }\r\n      // prevent added nodes from also triggering 'change' event (which is called next)\r\n      this.engine.addedNodes.forEach(n => { delete n._dirty; });\r\n      const addedNodes = [...this.engine.addedNodes];\r\n      this.engine.addedNodes = [];\r\n      this._triggerEvent('added', addedNodes);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  public _triggerRemoveEvent(): GridStack {\r\n    if (this.engine.batchMode) return this;\r\n    if (this.engine.removedNodes?.length) {\r\n      const removedNodes = [...this.engine.removedNodes];\r\n      this.engine.removedNodes = [];\r\n      this._triggerEvent('removed', removedNodes);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _triggerEvent(type: string, data?: GridStackNode[]): GridStack {\r\n    let event = data ? new CustomEvent(type, { bubbles: false, detail: data }) : new Event(type);\r\n    this.el.dispatchEvent(event);\r\n    return this;\r\n  }\r\n\r\n  /** @internal called to delete the current dynamic style sheet used for our layout */\r\n  protected _removeStylesheet(): GridStack {\r\n\r\n    if (this._styles) {\r\n      const styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode as HTMLElement;\r\n      Utils.removeStylesheet(this._styleSheetClass, styleLocation);\r\n      delete this._styles;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal updated/create the CSS styles for row based layout and initial margin setting */\r\n  protected _updateStyles(forceUpdate = false, maxH?: number): GridStack {\r\n    // call to delete existing one if we change cellHeight / margin\r\n    if (forceUpdate) {\r\n      this._removeStylesheet();\r\n    }\r\n\r\n    if (maxH === undefined) maxH = this.getRow();\r\n    this._updateContainerHeight();\r\n\r\n    // if user is telling us they will handle the CSS themselves by setting heights to 0. Do we need this opts really ??\r\n    if (this.opts.cellHeight === 0) {\r\n      return this;\r\n    }\r\n\r\n    let cellHeight = this.opts.cellHeight as number;\r\n    let cellHeightUnit = this.opts.cellHeightUnit;\r\n    let prefix = `.${this._styleSheetClass} > .${this.opts.itemClass}`;\r\n\r\n    // create one as needed\r\n    if (!this._styles) {\r\n      // insert style to parent (instead of 'head' by default) to support WebComponent\r\n      const styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode as HTMLElement;\r\n      this._styles = Utils.createStylesheet(this._styleSheetClass, styleLocation, {\r\n        nonce: this.opts.nonce,\r\n      });\r\n      if (!this._styles) return this;\r\n      this._styles._max = 0;\r\n\r\n      // these are done once only\r\n      Utils.addCSSRule(this._styles, prefix, `height: ${cellHeight}${cellHeightUnit}`);\r\n      // content margins\r\n      let top: string = this.opts.marginTop + this.opts.marginUnit;\r\n      let bottom: string = this.opts.marginBottom + this.opts.marginUnit;\r\n      let right: string = this.opts.marginRight + this.opts.marginUnit;\r\n      let left: string = this.opts.marginLeft + this.opts.marginUnit;\r\n      let content = `${prefix} > .grid-stack-item-content`;\r\n      let placeholder = `.${this._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`;\r\n      Utils.addCSSRule(this._styles, content, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\r\n      Utils.addCSSRule(this._styles, placeholder, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\r\n      // resize handles offset (to match margin)\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-n`, `top: ${top};`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-s`, `bottom: ${bottom}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-ne`, `right: ${right}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-e`, `right: ${right}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-se`, `right: ${right}; bottom: ${bottom}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-nw`, `left: ${left}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-w`, `left: ${left}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-sw`, `left: ${left}; bottom: ${bottom}`);\r\n    }\r\n\r\n    // now update the height specific fields\r\n    maxH = maxH || this._styles._max;\r\n    if (maxH > this._styles._max) {\r\n      let getHeight = (rows: number): string => (cellHeight * rows) + cellHeightUnit;\r\n      for (let i = this._styles._max + 1; i <= maxH; i++) { // start at 1\r\n        Utils.addCSSRule(this._styles, `${prefix}[gs-y=\"${i}\"]`, `top: ${getHeight(i)}`);\r\n        Utils.addCSSRule(this._styles, `${prefix}[gs-h=\"${i + 1}\"]`, `height: ${getHeight(i + 1)}`); // start at 2\r\n      }\r\n      this._styles._max = maxH;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _updateContainerHeight(): GridStack {\r\n    if (!this.engine || this.engine.batchMode) return this;\r\n    const parent = this.parentGridItem;\r\n    let row = this.getRow() + this._extraDragRow; // this checks for minRow already\r\n    const cellHeight = this.opts.cellHeight as number;\r\n    const unit = this.opts.cellHeightUnit;\r\n    if (!cellHeight) return this;\r\n\r\n    // check for css min height (non nested grid). TODO: support mismatch, say: min % while unit is px.\r\n    if (!parent) {\r\n      const cssMinHeight = Utils.parseHeight(getComputedStyle(this.el)['minHeight']);\r\n      if (cssMinHeight.h > 0 && cssMinHeight.unit === unit) {\r\n        const minRow = Math.floor(cssMinHeight.h / cellHeight);\r\n        if (row < minRow) {\r\n          row = minRow;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.el.setAttribute('gs-current-row', String(row));\r\n    this.el.style.removeProperty('min-height');\r\n    this.el.style.removeProperty('height');\r\n    if (row) {\r\n      // nested grids have 'insert:0' to fill the space of parent by default, but we may be taller so use min-height for possible scrollbars\r\n      this.el.style[parent ? 'minHeight' : 'height'] = row * cellHeight + unit;\r\n    }\r\n\r\n    // if we're a nested grid inside an sizeToContent item, tell it to resize itself too\r\n    if (parent && !parent.grid.engine.batchMode && Utils.shouldSizeToContent(parent)) {\r\n      parent.grid.resizeToContentCBCheck(parent.el);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _prepareElement(el: GridItemHTMLElement, triggerAddEvent = false, node?: GridStackNode): GridStack {\r\n    node = node || this._readAttr(el);\r\n    el.gridstackNode = node;\r\n    node.el = el;\r\n    node.grid = this;\r\n    node = this.engine.addNode(node, triggerAddEvent);\r\n\r\n    // write the dom sizes and class\r\n    this._writeAttr(el, node);\r\n    el.classList.add(gridDefaults.itemClass, this.opts.itemClass);\r\n    const sizeToContent = Utils.shouldSizeToContent(node);\r\n    sizeToContent ? el.classList.add('size-to-content') : el.classList.remove('size-to-content');\r\n    if (sizeToContent) this.resizeToContentCheck(false, node);\r\n\r\n    this._prepareDragDropByNode(node);\r\n    return this;\r\n  }\r\n\r\n  /** @internal call to write position x,y,w,h attributes back to element */\r\n  protected _writePosAttr(el: HTMLElement, n: GridStackPosition): GridStack {\r\n    if (n.x !== undefined && n.x !== null) { el.setAttribute('gs-x', String(n.x)); }\r\n    if (n.y !== undefined && n.y !== null) { el.setAttribute('gs-y', String(n.y)); }\r\n    n.w > 1 ? el.setAttribute('gs-w', String(n.w)) : el.removeAttribute('gs-w');\r\n    n.h > 1 ? el.setAttribute('gs-h', String(n.h)) : el.removeAttribute('gs-h');\r\n    return this;\r\n  }\r\n\r\n  /** @internal call to write any default attributes back to element */\r\n  protected _writeAttr(el: HTMLElement, node: GridStackWidget): GridStack {\r\n    if (!node) return this;\r\n    this._writePosAttr(el, node);\r\n\r\n    let attrs /*: GridStackWidget but strings */ = { // remaining attributes\r\n      autoPosition: 'gs-auto-position',\r\n      noResize: 'gs-no-resize',\r\n      noMove: 'gs-no-move',\r\n      locked: 'gs-locked',\r\n      id: 'gs-id',\r\n    };\r\n    for (const key in attrs) {\r\n      if (node[key]) { // 0 is valid for x,y only but done above already and not in list anyway\r\n        el.setAttribute(attrs[key], String(node[key]));\r\n      } else {\r\n        el.removeAttribute(attrs[key]);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal call to read any default attributes from element */\r\n  protected _readAttr(el: HTMLElement, clearDefaultAttr = true): GridStackWidget {\r\n    let n: GridStackNode = {};\r\n    n.x = Utils.toNumber(el.getAttribute('gs-x'));\r\n    n.y = Utils.toNumber(el.getAttribute('gs-y'));\r\n    n.w = Utils.toNumber(el.getAttribute('gs-w'));\r\n    n.h = Utils.toNumber(el.getAttribute('gs-h'));\r\n    n.autoPosition = Utils.toBool(el.getAttribute('gs-auto-position'));\r\n    n.noResize = Utils.toBool(el.getAttribute('gs-no-resize'));\r\n    n.noMove = Utils.toBool(el.getAttribute('gs-no-move'));\r\n    n.locked = Utils.toBool(el.getAttribute('gs-locked'));\r\n    n.id = el.getAttribute('gs-id');\r\n\r\n    // read but never written out\r\n    n.maxW = Utils.toNumber(el.getAttribute('gs-max-w'));\r\n    n.minW = Utils.toNumber(el.getAttribute('gs-min-w'));\r\n    n.maxH = Utils.toNumber(el.getAttribute('gs-max-h'));\r\n    n.minH = Utils.toNumber(el.getAttribute('gs-min-h'));\r\n\r\n    // v8.x optimization to reduce un-needed attr that don't render or are default CSS\r\n    if (clearDefaultAttr) {\r\n      if (n.w === 1) el.removeAttribute('gs-w');\r\n      if (n.h === 1) el.removeAttribute('gs-h');\r\n      if (n.maxW) el.removeAttribute('gs-max-w');\r\n      if (n.minW) el.removeAttribute('gs-min-w');\r\n      if (n.maxH) el.removeAttribute('gs-max-h');\r\n      if (n.minH) el.removeAttribute('gs-min-h');\r\n    }\r\n\r\n    // remove any key not found (null or false which is default)\r\n    for (const key in n) {\r\n      if (!n.hasOwnProperty(key)) return;\r\n      if (!n[key] && n[key] !== 0) { // 0 can be valid value (x,y only really)\r\n        delete n[key];\r\n      }\r\n    }\r\n\r\n    return n;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _setStaticClass(): GridStack {\r\n    let classes = ['grid-stack-static'];\r\n\r\n    if (this.opts.staticGrid) {\r\n      this.el.classList.add(...classes);\r\n      this.el.setAttribute('gs-static', 'true');\r\n    } else {\r\n      this.el.classList.remove(...classes);\r\n      this.el.removeAttribute('gs-static');\r\n\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * called when we are being resized - check if the one Column Mode needs to be turned on/off\r\n   * and remember the prev columns we used, or get our count from parent, as well as check for cellHeight==='auto' (square)\r\n   * or `sizeToContent` gridItem options.\r\n   */\r\n  public onResize(): GridStack {\r\n    if (!this.el?.clientWidth) return; // return if we're gone or no size yet (will get called again)\r\n    if (this.prevWidth === this.el.clientWidth) return; // no-op\r\n    this.prevWidth = this.el.clientWidth\r\n    // console.log('onResize ', this.el.clientWidth);\r\n\r\n    this.batchUpdate();\r\n\r\n    // see if we're nested and take our column count from our parent....\r\n    let columnChanged = false;\r\n    if (this._autoColumn && this.parentGridItem) {\r\n      if (this.opts.column !== this.parentGridItem.w) {\r\n        this.column(this.parentGridItem.w, 'none');\r\n        columnChanged = true;\r\n      }\r\n    } else {\r\n      // else check for dynamic column\r\n      columnChanged = this.checkDynamicColumn();\r\n    }\r\n\r\n    // make the cells content square again\r\n    if (this._isAutoCellHeight) this.cellHeight();\r\n\r\n    // update any nested grids, or items size\r\n    this.engine.nodes.forEach(n => {\r\n      if (n.subGrid) n.subGrid.onResize()\r\n    });\r\n\r\n    if (!this._skipInitialResize) this.resizeToContentCheck(columnChanged); // wait for anim of column changed (DOM reflow before we can size correctly)\r\n    delete this._skipInitialResize;\r\n\r\n    this.batchUpdate(false);\r\n\r\n    return this;\r\n  }\r\n\r\n  /** resizes content for given node (or all) if shouldSizeToContent() is true */\r\n  private resizeToContentCheck(delay = false, n: GridStackNode = undefined) {\r\n    if (!this.engine) return; // we've been deleted in between!\r\n\r\n    // update any gridItem height with sizeToContent, but wait for DOM $animation_speed to settle if we changed column count\r\n    // TODO: is there a way to know what the final (post animation) size of the content will be so we can animate the column width and height together rather than sequentially ?\r\n    if (delay && this.hasAnimationCSS()) return setTimeout(() => this.resizeToContentCheck(false, n), 300 + 10);\r\n\r\n    if (n) {\r\n      if (Utils.shouldSizeToContent(n)) this.resizeToContentCBCheck(n.el);\r\n    } else if (this.engine.nodes.some(n => Utils.shouldSizeToContent(n))) {\r\n      const nodes = [...this.engine.nodes]; // in case order changes while resizing one\r\n      this.batchUpdate();\r\n      nodes.forEach(n => {\r\n        if (Utils.shouldSizeToContent(n)) this.resizeToContentCBCheck(n.el);\r\n      });\r\n      this.batchUpdate(false);\r\n    }\r\n    // call this regardless of shouldSizeToContent because widget might need to stretch to take available space after a resize\r\n    if (this._gsEventHandler['resizecontent']) this._gsEventHandler['resizecontent'](null, n ? [n] : this.engine.nodes);\r\n  }\r\n\r\n  /** add or remove the grid element size event handler */\r\n  protected _updateResizeEvent(forceRemove = false): GridStack {\r\n    // only add event if we're not nested (parent will call us) and we're auto sizing cells or supporting dynamic column (i.e. doing work)\r\n    // or supporting new sizeToContent option.\r\n    const trackSize = !this.parentGridItem && (this._isAutoCellHeight || this.opts.sizeToContent || this.opts.columnOpts\r\n      || this.engine.nodes.find(n => n.sizeToContent));\r\n\r\n    if (!forceRemove && trackSize && !this.resizeObserver) {\r\n      this._sizeThrottle = Utils.throttle(() => this.onResize(), this.opts.cellHeightThrottle);\r\n      this.resizeObserver = new ResizeObserver(() => this._sizeThrottle());\r\n      this.resizeObserver.observe(this.el);\r\n      this._skipInitialResize = true; // makeWidget will originally have called on startup\r\n    } else if ((forceRemove || !trackSize) && this.resizeObserver) {\r\n      this.resizeObserver.disconnect();\r\n      delete this.resizeObserver;\r\n      delete this._sizeThrottle;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal convert a potential selector into actual element */\r\n  public static getElement(els: GridStackElement = '.grid-stack-item'): GridItemHTMLElement { return Utils.getElement(els) }\r\n  /** @internal */\r\n  public static getElements(els: GridStackElement = '.grid-stack-item'): GridItemHTMLElement[] { return Utils.getElements(els) }\r\n  /** @internal */\r\n  public static getGridElement(els: GridStackElement): GridHTMLElement { return GridStack.getElement(els) }\r\n  /** @internal */\r\n  public static getGridElements(els: string): GridHTMLElement[] { return Utils.getElements(els) }\r\n\r\n  /** @internal initialize margin top/bottom/left/right and units */\r\n  protected _initMargin(): GridStack {\r\n\r\n    let data: HeightData;\r\n    let margin = 0;\r\n\r\n    // support passing multiple values like CSS (ex: '5px 10px 0 20px')\r\n    let margins: string[] = [];\r\n    if (typeof this.opts.margin === 'string') {\r\n      margins = this.opts.margin.split(' ')\r\n    }\r\n    if (margins.length === 2) { // top/bot, left/right like CSS\r\n      this.opts.marginTop = this.opts.marginBottom = margins[0];\r\n      this.opts.marginLeft = this.opts.marginRight = margins[1];\r\n    } else if (margins.length === 4) { // Clockwise like CSS\r\n      this.opts.marginTop = margins[0];\r\n      this.opts.marginRight = margins[1];\r\n      this.opts.marginBottom = margins[2];\r\n      this.opts.marginLeft = margins[3];\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.margin);\r\n      this.opts.marginUnit = data.unit;\r\n      margin = this.opts.margin = data.h;\r\n    }\r\n\r\n    // see if top/bottom/left/right need to be set as well\r\n    if (this.opts.marginTop === undefined) {\r\n      this.opts.marginTop = margin;\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.marginTop);\r\n      this.opts.marginTop = data.h;\r\n      delete this.opts.margin;\r\n    }\r\n\r\n    if (this.opts.marginBottom === undefined) {\r\n      this.opts.marginBottom = margin;\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.marginBottom);\r\n      this.opts.marginBottom = data.h;\r\n      delete this.opts.margin;\r\n    }\r\n\r\n    if (this.opts.marginRight === undefined) {\r\n      this.opts.marginRight = margin;\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.marginRight);\r\n      this.opts.marginRight = data.h;\r\n      delete this.opts.margin;\r\n    }\r\n\r\n    if (this.opts.marginLeft === undefined) {\r\n      this.opts.marginLeft = margin;\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.marginLeft);\r\n      this.opts.marginLeft = data.h;\r\n      delete this.opts.margin;\r\n    }\r\n    this.opts.marginUnit = data.unit; // in case side were spelled out, use those units instead...\r\n    if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {\r\n      this.opts.margin = this.opts.marginTop; // makes it easier to check for no-ops in setMargin()\r\n    }\r\n    return this;\r\n  }\r\n\r\n  static GDRev = '10.3.1';\r\n\r\n  /* ===========================================================================================\r\n   * drag&drop methods that used to be stubbed out and implemented in dd-gridstack.ts\r\n   * but caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\r\n   * ===========================================================================================\r\n   */\r\n\r\n  /** get the global (but static to this code) DD implementation */\r\n  public static getDD(): DDGridStack {\r\n    return dd;\r\n  }\r\n\r\n  /**\r\n   * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.\r\n   * Called during GridStack.init() as options, but can also be called directly (last param are used) in case the toolbar\r\n   * is dynamically create and needs to be set later.\r\n   * @param dragIn string selector (ex: '.sidebar .grid-stack-item') or list of dom elements\r\n   * @param dragInOptions options - see DDDragInOpt. (default: {handle: '.grid-stack-item-content', appendTo: 'body'}\r\n   * @param root optional root which defaults to document (for shadow dom pas the parent HTMLDocument)\r\n   */\r\n  public static setupDragIn(dragIn?: string | HTMLElement[], dragInOptions?: DDDragInOpt, root: HTMLElement | Document = document): void {\r\n    if (dragInOptions?.pause !== undefined) {\r\n      DDManager.pauseDrag = dragInOptions.pause;\r\n    }\r\n\r\n    dragInOptions = { ...dragInDefaultOptions, ...(dragInOptions || {}) };\r\n    let els: HTMLElement[] = (typeof dragIn === 'string') ? Utils.getElements(dragIn, root) : dragIn;\r\n    if (els.length) els?.forEach(el => {\r\n      if (!dd.isDraggable(el)) dd.dragIn(el, dragInOptions);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Enables/Disables dragging by the user of specific grid element. If you want all items, and have it affect future items, use enableMove() instead. No-op for static grids.\r\n   * IF you are looking to prevent an item from moving (due to being pushed around by another during collision) use locked property instead.\r\n   * @param els widget or selector to modify.\r\n   * @param val if true widget will be draggable, assuming the parent grid isn't noMove or static.\r\n   */\r\n  public movable(els: GridStackElement, val: boolean): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't move a static grid!\r\n    GridStack.getElements(els).forEach(el => {\r\n      const n = el.gridstackNode;\r\n      if (!n) return;\r\n      val ? delete n.noMove : n.noMove = true;\r\n      this._prepareDragDropByNode(n); // init DD if need be, and adjust\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enables/Disables user resizing of specific grid element. If you want all items, and have it affect future items, use enableResize() instead. No-op for static grids.\r\n   * @param els  widget or selector to modify\r\n   * @param val  if true widget will be resizable, assuming the parent grid isn't noResize or static.\r\n   */\r\n  public resizable(els: GridStackElement, val: boolean): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't resize a static grid!\r\n    GridStack.getElements(els).forEach(el => {\r\n      let n = el.gridstackNode;\r\n      if (!n) return;\r\n      val ? delete n.noResize : n.noResize = true;\r\n      this._prepareDragDropByNode(n); // init DD if need be, and adjust\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Temporarily disables widgets moving/resizing.\r\n   * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.\r\n   * Note: no-op for static grid\r\n   * This is a shortcut for:\r\n   * @example\r\n   *  grid.enableMove(false);\r\n   *  grid.enableResize(false);\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public disable(recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return;\r\n    this.enableMove(false, recurse);\r\n    this.enableResize(false, recurse);\r\n    this._triggerEvent('disable');\r\n    return this;\r\n  }\r\n  /**\r\n   * Re-enables widgets moving/resizing - see disable().\r\n   * Note: no-op for static grid.\r\n   * This is a shortcut for:\r\n   * @example\r\n   *  grid.enableMove(true);\r\n   *  grid.enableResize(true);\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public enable(recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return;\r\n    this.enableMove(true, recurse);\r\n    this.enableResize(true, recurse);\r\n    this._triggerEvent('enable');\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enables/disables widget moving. No-op for static grids, and locally defined items still overrule\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public enableMove(doEnable: boolean, recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't move a static grid!\r\n    doEnable ? delete this.opts.disableDrag : this.opts.disableDrag = true; // FIRST before we update children as grid overrides #1658\r\n    this.engine.nodes.forEach(n => {\r\n      this._prepareDragDropByNode(n);\r\n      if (n.subGrid && recurse) n.subGrid.enableMove(doEnable, recurse);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enables/disables widget resizing. No-op for static grids.\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public enableResize(doEnable: boolean, recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't size a static grid!\r\n    doEnable ? delete this.opts.disableResize : this.opts.disableResize = true; // FIRST before we update children as grid overrides #1658\r\n    this.engine.nodes.forEach(n => {\r\n      this._prepareDragDropByNode(n);\r\n      if (n.subGrid && recurse) n.subGrid.enableResize(doEnable, recurse);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /** @internal removes any drag&drop present (called during destroy) */\r\n  protected _removeDD(el: DDElementHost): GridStack {\r\n    dd.draggable(el, 'destroy').resizable(el, 'destroy');\r\n    if (el.gridstackNode) {\r\n      delete el.gridstackNode._initDD; // reset our DD init flag\r\n    }\r\n    delete el.ddElement;\r\n    return this;\r\n  }\r\n\r\n  /** @internal called to add drag over to support widgets being added externally */\r\n  protected _setupAcceptWidget(): GridStack {\r\n\r\n    // check if we need to disable things\r\n    if (this.opts.staticGrid || (!this.opts.acceptWidgets && !this.opts.removable)) {\r\n      dd.droppable(this.el, 'destroy');\r\n      return this;\r\n    }\r\n\r\n    // vars shared across all methods\r\n    let cellHeight: number, cellWidth: number;\r\n\r\n    let onDrag = (event: DragEvent, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n      let node = el.gridstackNode;\r\n      if (!node) return;\r\n\r\n      helper = helper || el;\r\n\r\n      // if the element is being dragged from outside, scale it down to match the grid's scale\r\n      // and slightly adjust its position relative to the mouse\r\n      if (!node.grid?.el) {\r\n        // this scales the helper down\r\n        helper.style.transform = `scale(${1 / this.dragTransform.xScale},${1 / this.dragTransform.yScale})`;\r\n        // this makes it so that the helper is well positioned relative to the mouse after scaling\r\n        const helperRect = helper.getBoundingClientRect();\r\n        helper.style.left = helperRect.x + (this.dragTransform.xScale - 1) * (event.clientX - helperRect.x) / this.dragTransform.xScale + 'px';\r\n        helper.style.top = helperRect.y + (this.dragTransform.yScale - 1) * (event.clientY - helperRect.y) / this.dragTransform.yScale + 'px';\r\n        helper.style.transformOrigin = `0px 0px`\r\n      }\r\n\r\n      let parent = this.el.getBoundingClientRect();\r\n      let { top, left } = helper.getBoundingClientRect();\r\n      left -= parent.left;\r\n      top -= parent.top;\r\n      let ui: DDUIData = {\r\n        position: {\r\n          top: top * this.dragTransform.xScale,\r\n          left: left * this.dragTransform.yScale\r\n        }\r\n      };\r\n\r\n      if (node._temporaryRemoved) {\r\n        node.x = Math.max(0, Math.round(left / cellWidth));\r\n        node.y = Math.max(0, Math.round(top / cellHeight));\r\n        delete node.autoPosition;\r\n        this.engine.nodeBoundFix(node);\r\n\r\n        // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere\r\n        if (!this.engine.willItFit(node)) {\r\n          node.autoPosition = true; // ignore x,y and try for any slot...\r\n          if (!this.engine.willItFit(node)) {\r\n            dd.off(el, 'drag'); // stop calling us\r\n            return; // full grid or can't grow\r\n          }\r\n          if (node._willFitPos) {\r\n            // use the auto position instead #1687\r\n            Utils.copyPos(node, node._willFitPos);\r\n            delete node._willFitPos;\r\n          }\r\n        }\r\n\r\n        // re-use the existing node dragging method\r\n        this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);\r\n      } else {\r\n        // re-use the existing node dragging that does so much of the collision detection\r\n        this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);\r\n      }\r\n    }\r\n\r\n    dd.droppable(this.el, {\r\n      accept: (el: GridItemHTMLElement) => {\r\n        let node: GridStackNode = el.gridstackNode || this._readAttr(el, false);\r\n        // set accept drop to true on ourself (which we ignore) so we don't get \"can't drop\" icon in HTML5 mode while moving\r\n        if (node?.grid === this) return true;\r\n        if (!this.opts.acceptWidgets) return false;\r\n        // check for accept method or class matching\r\n        let canAccept = true;\r\n        if (typeof this.opts.acceptWidgets === 'function') {\r\n          canAccept = this.opts.acceptWidgets(el);\r\n        } else {\r\n          let selector = (this.opts.acceptWidgets === true ? '.grid-stack-item' : this.opts.acceptWidgets as string);\r\n          canAccept = el.matches(selector);\r\n        }\r\n        // finally check to make sure we actually have space left #1571 #2633\r\n        if (canAccept && node && this.opts.maxRow) {\r\n          let n = { w: node.w, h: node.h, minW: node.minW, minH: node.minH }; // only width/height matters and autoPosition\r\n          canAccept = this.engine.willItFit(n);\r\n        }\r\n        return canAccept;\r\n      }\r\n    })\r\n      /**\r\n       * entering our grid area\r\n       */\r\n      .on(this.el, 'dropover', (event: Event, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n        // console.log(`over ${this.el.gridstack.opts.id} ${count++}`); // TEST\r\n        let node = el.gridstackNode;\r\n        // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item\r\n        if (node?.grid === this && !node._temporaryRemoved) {\r\n          // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)\r\n          return false; // prevent parent from receiving msg (which may be a grid as well)\r\n        }\r\n\r\n        // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now\r\n        if (node?.grid && node.grid !== this && !node._temporaryRemoved) {\r\n          // console.log('dropover without leave'); // TEST\r\n          let otherGrid = node.grid;\r\n          otherGrid._leave(el, helper);\r\n        }\r\n\r\n        // cache cell dimensions (which don't change), position can animate if we removed an item in otherGrid that affects us...\r\n        cellWidth = this.cellWidth();\r\n        cellHeight = this.getCellHeight(true);\r\n\r\n        // load any element attributes if we don't have a node\r\n        if (!node) {\r\n          node = this._readAttr(el, false); // don't wipe external (e.g. drag toolbar) attr #2354\r\n        }\r\n        if (!node.grid) {\r\n          node._isExternal = true;\r\n          el.gridstackNode = node;\r\n        }\r\n\r\n        // calculate the grid size based on element outer size\r\n        helper = helper || el;\r\n        let w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;\r\n        let h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;\r\n\r\n        // if the item came from another grid, make a copy and save the original info in case we go back there\r\n        if (node.grid && node.grid !== this) {\r\n          // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific\r\n          // console.log('dropover cloning node'); // TEST\r\n          if (!el._gridstackNodeOrig) el._gridstackNodeOrig = node; // shouldn't have multiple nested!\r\n          el.gridstackNode = node = { ...node, w, h, grid: this };\r\n          delete node.x;\r\n          delete node.y;\r\n          this.engine.cleanupNode(node)\r\n            .nodeBoundFix(node);\r\n          // restore some internal fields we need after clearing them all\r\n          node._initDD =\r\n            node._isExternal =  // DOM needs to be re-parented on a drop\r\n            node._temporaryRemoved = true; // so it can be inserted onDrag below\r\n        } else {\r\n          node.w = w; node.h = h;\r\n          node._temporaryRemoved = true; // so we can insert it\r\n        }\r\n\r\n        // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)\r\n        GridStack._itemRemoving(node.el, false);\r\n\r\n        dd.on(el, 'drag', onDrag);\r\n        // make sure this is called at least once when going fast #1578\r\n        onDrag(event as DragEvent, el, helper);\r\n        return false; // prevent parent from receiving msg (which may be a grid as well)\r\n      })\r\n      /**\r\n       * Leaving our grid area...\r\n       */\r\n      .on(this.el, 'dropout', (event, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n        // console.log(`out ${this.el.gridstack.opts.id} ${count++}`); // TEST\r\n        let node = el.gridstackNode;\r\n        if (!node) return false;\r\n        // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)\r\n        // so skip this one if we're not the active grid really..\r\n        if (!node.grid || node.grid === this) {\r\n          this._leave(el, helper);\r\n          // if we were created as temporary nested grid, go back to before state\r\n          if (this._isTemp) {\r\n            this.removeAsSubGrid(node);\r\n          }\r\n        }\r\n        return false; // prevent parent from receiving msg (which may be grid as well)\r\n      })\r\n      /**\r\n       * end - releasing the mouse\r\n       */\r\n      .on(this.el, 'drop', (event, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n        let node = el.gridstackNode;\r\n        // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead\r\n        if (node?.grid === this && !node._isExternal) return false;\r\n\r\n        const wasAdded = !!this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419\r\n        this.placeholder.remove();\r\n\r\n        // disable animation when replacing a placeholder (already positioned) with actual content\r\n        const noAnim = wasAdded && this.opts.animate;\r\n        if (noAnim) this.setAnimation(false);\r\n\r\n        // notify previous grid of removal\r\n        // console.log('drop delete _gridstackNodeOrig') // TEST\r\n        let origNode = el._gridstackNodeOrig;\r\n        delete el._gridstackNodeOrig;\r\n        if (wasAdded && origNode?.grid && origNode.grid !== this) {\r\n          let oGrid = origNode.grid;\r\n          oGrid.engine.removeNodeFromLayoutCache(origNode);\r\n          oGrid.engine.removedNodes.push(origNode);\r\n          oGrid._triggerRemoveEvent()._triggerChangeEvent();\r\n          // if it's an empty sub-grid that got auto-created, nuke it\r\n          if (oGrid.parentGridItem && !oGrid.engine.nodes.length && oGrid.opts.subGridDynamic) {\r\n            oGrid.removeAsSubGrid();\r\n          }\r\n        }\r\n\r\n        if (!node) return false;\r\n\r\n        // use existing placeholder node as it's already in our list with drop location\r\n        if (wasAdded) {\r\n          this.engine.cleanupNode(node); // removes all internal _xyz values\r\n          node.grid = this;\r\n        }\r\n        delete node.grid?._isTemp;\r\n        dd.off(el, 'drag');\r\n        // if we made a copy ('helper' which is temp) of the original node then insert a copy, else we move the original node (#1102)\r\n        // as the helper will be nuked by jquery-ui otherwise. TODO: update old code path\r\n        if (helper !== el) {\r\n          helper.remove();\r\n          el.gridstackNode = origNode; // original item (left behind) is re-stored to pre dragging as the node now has drop info\r\n          if (wasAdded) {\r\n            el = el.cloneNode(true) as GridItemHTMLElement;\r\n          }\r\n        } else {\r\n          el.remove(); // reduce flicker as we change depth here, and size further down\r\n          this._removeDD(el);\r\n        }\r\n        if (!wasAdded) return false;\r\n        el.gridstackNode = node;\r\n        node.el = el;\r\n        let subGrid = node.subGrid?.el?.gridstack; // set when actual sub-grid present\r\n        // @ts-ignore\r\n        Utils.copyPos(node, this._readAttr(this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578\r\n        Utils.removePositioningStyles(el);// @ts-ignore\r\n        this.el.appendChild(el);// @ts-ignore // TODO: now would be ideal time to _removeHelperStyle() overriding floating styles (native only)\r\n        this._prepareElement(el, true, node);\r\n        if (subGrid) {\r\n          subGrid.parentGridItem = node;\r\n          if (!subGrid.opts.styleInHead) subGrid._updateStyles(true); // re-create sub-grid styles now that we've moved\r\n        }\r\n        this._updateContainerHeight();\r\n        this.engine.addedNodes.push(node);// @ts-ignore\r\n        this._triggerAddEvent();// @ts-ignore\r\n        this._triggerChangeEvent();\r\n\r\n        this.engine.endUpdate();\r\n        if (this._gsEventHandler['dropped']) {\r\n          this._gsEventHandler['dropped']({ ...event, type: 'dropped' }, origNode && origNode.grid ? origNode : undefined, node);\r\n        }\r\n\r\n        // delay adding animation back\r\n        if (noAnim) this.setAnimation(this.opts.animate, true);\r\n\r\n        return false; // prevent parent from receiving msg (which may be grid as well)\r\n      });\r\n    return this;\r\n  }\r\n\r\n  /** @internal mark item for removal */\r\n  private static _itemRemoving(el: GridItemHTMLElement, remove: boolean) {\r\n    const node = el ? el.gridstackNode : undefined;\r\n    if (!node?.grid || el.classList.contains(node.grid.opts.removableOptions.decline)) return;\r\n    remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;\r\n    remove ? el.classList.add('grid-stack-item-removing') : el.classList.remove('grid-stack-item-removing');\r\n  }\r\n\r\n  /** @internal called to setup a trash drop zone if the user specifies it */\r\n  protected _setupRemoveDrop(): GridStack {\r\n    if (typeof this.opts.removable !== 'string') return this;\r\n    let trashEl = document.querySelector(this.opts.removable) as HTMLElement;\r\n    if (!trashEl) return this;\r\n\r\n    // only register ONE static drop-over/dropout callback for the 'trash', and it will\r\n    // update the passed in item and parent grid because the '.trash' is a shared resource anyway,\r\n    // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)\r\n    if (!this.opts.staticGrid && !dd.isDroppable(trashEl)) {\r\n      dd.droppable(trashEl, this.opts.removableOptions)\r\n        .on(trashEl, 'dropover', (event, el) => GridStack._itemRemoving(el, true))\r\n        .on(trashEl, 'dropout', (event, el) => GridStack._itemRemoving(el, false));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal prepares the element for drag&drop */\r\n  protected _prepareDragDropByNode(node: GridStackNode): GridStack {\r\n    let el = node.el;\r\n    const noMove = node.noMove || this.opts.disableDrag;\r\n    const noResize = node.noResize || this.opts.disableResize;\r\n\r\n    // check for disabled grid first\r\n    if (this.opts.staticGrid || (noMove && noResize)) {\r\n      if (node._initDD) {\r\n        this._removeDD(el); // nukes everything instead of just disable, will add some styles back next\r\n        delete node._initDD;\r\n      }\r\n      el.classList.add('ui-draggable-disabled', 'ui-resizable-disabled'); // add styles one might depend on #1435\r\n      return this;\r\n    }\r\n\r\n    if (!node._initDD) {\r\n      // variables used/cashed between the 3 start/move/end methods, in addition to node passed above\r\n      let cellWidth: number;\r\n      let cellHeight: number;\r\n\r\n      /** called when item starts moving/resizing */\r\n      let onStartMoving = (event: Event, ui: DDUIData) => {\r\n        // trigger any 'dragstart' / 'resizestart' manually\r\n        if (this._gsEventHandler[event.type]) {\r\n          this._gsEventHandler[event.type](event, event.target);\r\n        }\r\n        cellWidth = this.cellWidth();\r\n        cellHeight = this.getCellHeight(true); // force pixels for calculations\r\n\r\n        this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);\r\n      }\r\n\r\n      /** called when item is being dragged/resized */\r\n      let dragOrResize = (event: MouseEvent, ui: DDUIData) => {\r\n        this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);\r\n      }\r\n\r\n      /** called when the item stops moving/resizing */\r\n      let onEndMoving = (event: Event) => {\r\n        this.placeholder.remove();\r\n        delete node._moving;\r\n        delete node._event;\r\n        delete node._lastTried;\r\n        const widthChanged = node.w !== node._orig.w;\r\n\r\n        // if the item has moved to another grid, we're done here\r\n        let target: GridItemHTMLElement = event.target as GridItemHTMLElement;\r\n        if (!target.gridstackNode || target.gridstackNode.grid !== this) return;\r\n\r\n        node.el = target;\r\n\r\n        if (node._isAboutToRemove) {\r\n          let grid = el.gridstackNode.grid;\r\n          if (grid._gsEventHandler[event.type]) {\r\n            grid._gsEventHandler[event.type](event, target);\r\n          }\r\n          grid.engine.nodes.push(node); // temp add it back so we can proper remove it next\r\n          grid.removeWidget(el, true, true);\r\n        } else {\r\n          Utils.removePositioningStyles(target);\r\n          if (node._temporaryRemoved) {\r\n            // got removed - restore item back to before dragging position\r\n            Utils.copyPos(node, node._orig);// @ts-ignore\r\n            this._writePosAttr(target, node);\r\n            this.engine.addNode(node);\r\n          } else {\r\n            // move to new placeholder location\r\n            this._writePosAttr(target, node);\r\n          }\r\n          if (this._gsEventHandler[event.type]) {\r\n            this._gsEventHandler[event.type](event, target);\r\n          }\r\n        }\r\n        // @ts-ignore\r\n        this._extraDragRow = 0;// @ts-ignore\r\n        this._updateContainerHeight();// @ts-ignore\r\n        this._triggerChangeEvent();\r\n\r\n        this.engine.endUpdate();\r\n\r\n        if (event.type === 'resizestop') {\r\n          if (Number.isInteger(node.sizeToContent)) node.sizeToContent = node.h; // new soft limit\r\n          this.resizeToContentCheck(widthChanged, node); // wait for width animation if changed\r\n        }\r\n      }\r\n\r\n      dd.draggable(el, {\r\n        start: onStartMoving,\r\n        stop: onEndMoving,\r\n        drag: dragOrResize\r\n      }).resizable(el, {\r\n        start: onStartMoving,\r\n        stop: onEndMoving,\r\n        resize: dragOrResize\r\n      });\r\n      node._initDD = true; // we've set DD support now\r\n    }\r\n\r\n    // finally fine tune move vs resize by disabling any part...\r\n    dd.draggable(el, noMove ? 'disable' : 'enable')\r\n      .resizable(el, noResize ? 'disable' : 'enable');\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal handles actual drag/resize start */\r\n  protected _onStartMoving(el: GridItemHTMLElement, event: Event, ui: DDUIData, node: GridStackNode, cellWidth: number, cellHeight: number): void {\r\n    this.engine.cleanNodes()\r\n      .beginUpdate(node);\r\n    // @ts-ignore\r\n    this._writePosAttr(this.placeholder, node)\r\n    this.el.appendChild(this.placeholder);\r\n    this.placeholder.gridstackNode = node;\r\n    // console.log('_onStartMoving placeholder') // TEST\r\n\r\n    // if the element is inside a grid, it has already been scaled\r\n    // we can use that as a scale reference\r\n    if (node.grid?.el) {\r\n      this.dragTransform = Utils.getValuesFromTransformedElement(el);\r\n    }\r\n    // if the element is being dragged from outside (not from any grid)\r\n    // we use the grid as the transformation reference, since the helper is not subject to transformation\r\n    else if (this.placeholder && this.placeholder.closest('.grid-stack')) {\r\n      const gridEl = this.placeholder.closest('.grid-stack') as HTMLElement;\r\n      this.dragTransform = Utils.getValuesFromTransformedElement(gridEl);\r\n    }\r\n    // Fallback\r\n    else {\r\n      this.dragTransform = {\r\n        xScale: 1,\r\n        xOffset: 0,\r\n        yScale: 1,\r\n        yOffset: 0,\r\n      }\r\n    }\r\n\r\n    node.el = this.placeholder;\r\n    node._lastUiPosition = ui.position;\r\n    node._prevYPix = ui.position.top;\r\n    node._moving = (event.type === 'dragstart'); // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)\r\n    delete node._lastTried;\r\n\r\n    if (event.type === 'dropover' && node._temporaryRemoved) {\r\n      // console.log('engine.addNode x=' + node.x); // TEST\r\n      this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved\r\n      node._moving = true; // AFTER, mark as moving object (wanted fix location before)\r\n    }\r\n\r\n    // set the min/max resize info taking into account the column count and position (so we don't resize outside the grid)\r\n    this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop as number, this.opts.marginRight as number, this.opts.marginBottom as number, this.opts.marginLeft as number);\r\n    if (event.type === 'resizestart') {\r\n      const colLeft = this.getColumn() - node.x;\r\n      const rowLeft = (this.opts.maxRow || Number.MAX_SAFE_INTEGER) - node.y;\r\n      dd.resizable(el, 'option', 'minWidth', cellWidth * Math.min(node.minW || 1, colLeft))\r\n        .resizable(el, 'option', 'minHeight', cellHeight * Math.min(node.minH || 1, rowLeft))\r\n        .resizable(el, 'option', 'maxWidth', cellWidth * Math.min(node.maxW || Number.MAX_SAFE_INTEGER, colLeft))\r\n        .resizable(el, 'option', 'maxWidthMoveLeft', cellWidth * Math.min(node.maxW || Number.MAX_SAFE_INTEGER, node.x+node.w))\r\n        .resizable(el, 'option', 'maxHeight', cellHeight * Math.min(node.maxH || Number.MAX_SAFE_INTEGER, rowLeft))\r\n        .resizable(el, 'option', 'maxHeightMoveUp', cellHeight * Math.min(node.maxH || Number.MAX_SAFE_INTEGER, node.y+node.h));\r\n    }\r\n  }\r\n\r\n  /** @internal handles actual drag/resize */\r\n  protected _dragOrResize(el: GridItemHTMLElement, event: MouseEvent, ui: DDUIData, node: GridStackNode, cellWidth: number, cellHeight: number): void {\r\n    let p = { ...node._orig }; // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)\r\n    let resizing: boolean;\r\n    let mLeft = this.opts.marginLeft as number,\r\n      mRight = this.opts.marginRight as number,\r\n      mTop = this.opts.marginTop as number,\r\n      mBottom = this.opts.marginBottom as number;\r\n\r\n    // if margins (which are used to pass mid point by) are large relative to cell height/width, reduce them down #1855\r\n    let mHeight = Math.round(cellHeight * 0.1),\r\n      mWidth = Math.round(cellWidth * 0.1);\r\n    mLeft = Math.min(mLeft, mWidth);\r\n    mRight = Math.min(mRight, mWidth);\r\n    mTop = Math.min(mTop, mHeight);\r\n    mBottom = Math.min(mBottom, mHeight);\r\n\r\n    if (event.type === 'drag') {\r\n      if (node._temporaryRemoved) return; // handled by dropover\r\n      let distance = ui.position.top - node._prevYPix;\r\n      node._prevYPix = ui.position.top;\r\n      if (this.opts.draggable.scroll !== false) {\r\n        Utils.updateScrollPosition(el, ui.position, distance);\r\n      }\r\n\r\n      // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)\r\n      let left = ui.position.left + (ui.position.left > node._lastUiPosition.left ? -mRight : mLeft);\r\n      let top = ui.position.top + (ui.position.top > node._lastUiPosition.top ? -mBottom : mTop);\r\n      p.x = Math.round(left / cellWidth);\r\n      p.y = Math.round(top / cellHeight);\r\n\r\n      // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others\r\n      let prev = this._extraDragRow;\r\n      if (this.engine.collide(node, p)) {\r\n        let row = this.getRow();\r\n        let extra = Math.max(0, (p.y + node.h) - row);\r\n        if (this.opts.maxRow && row + extra > this.opts.maxRow) {\r\n          extra = Math.max(0, this.opts.maxRow - row);\r\n        }// @ts-ignore\r\n        this._extraDragRow = extra;// @ts-ignore\r\n      } else this._extraDragRow = 0;// @ts-ignore\r\n      if (this._extraDragRow !== prev) this._updateContainerHeight();\r\n\r\n      if (node.x === p.x && node.y === p.y) return; // skip same\r\n      // DON'T skip one we tried as we might have failed because of coverage <50% before\r\n      // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;\r\n    } else if (event.type === 'resize') {\r\n      if (p.x < 0) return;\r\n      // Scrolling page if needed\r\n      Utils.updateScrollResize(event, el, cellHeight);\r\n\r\n      // get new size\r\n      p.w = Math.round((ui.size.width - mLeft) / cellWidth);\r\n      p.h = Math.round((ui.size.height - mTop) / cellHeight);\r\n      if (node.w === p.w && node.h === p.h) return;\r\n      if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h) return; // skip one we tried (but failed)\r\n\r\n      // if we size on left/top side this might move us, so get possible new position as well\r\n      let left = ui.position.left + mLeft;\r\n      let top = ui.position.top + mTop;\r\n      p.x = Math.round(left / cellWidth);\r\n      p.y = Math.round(top / cellHeight);\r\n\r\n      resizing = true;\r\n    }\r\n\r\n    node._event = event;\r\n    node._lastTried = p; // set as last tried (will nuke if we go there)\r\n    let rect: GridStackPosition = { // screen pix of the dragged box\r\n      x: ui.position.left + mLeft,\r\n      y: ui.position.top + mTop,\r\n      w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,\r\n      h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom\r\n    };\r\n    if (this.engine.moveNodeCheck(node, { ...p, cellWidth, cellHeight, rect, resizing })) {\r\n      node._lastUiPosition = ui.position;\r\n      this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);\r\n      delete node._skipDown;\r\n      if (resizing && node.subGrid) node.subGrid.onResize();\r\n      this._extraDragRow = 0;// @ts-ignore\r\n      this._updateContainerHeight();\r\n\r\n      let target = event.target as GridItemHTMLElement;// @ts-ignore\r\n      this._writePosAttr(target, node);\r\n      if (this._gsEventHandler[event.type]) {\r\n        this._gsEventHandler[event.type](event, target);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @internal called when item leaving our area by either cursor dropout event\r\n   * or shape is outside our boundaries. remove it from us, and mark temporary if this was\r\n   * our item to start with else restore prev node values from prev grid it came from.\r\n   */\r\n  protected _leave(el: GridItemHTMLElement, helper?: GridItemHTMLElement): void {\r\n    let node = el.gridstackNode;\r\n    if (!node) return;\r\n\r\n    helper = helper || el;\r\n    // restore the scale of the helper on leave\r\n    helper.style.transform = 'scale(1)';\r\n    dd.off(el, 'drag'); // no need to track while being outside\r\n\r\n    // this gets called when cursor leaves and shape is outside, so only do this once\r\n    if (node._temporaryRemoved) return;\r\n    node._temporaryRemoved = true;\r\n\r\n    this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue\r\n    node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged\r\n\r\n    if (this.opts.removable === true) { // boolean vs a class string\r\n      // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so\r\n      GridStack._itemRemoving(el, true);\r\n    }\r\n\r\n    // finally if item originally came from another grid, but left us, restore things back to prev info\r\n    if (el._gridstackNodeOrig) {\r\n      // console.log('leave delete _gridstackNodeOrig') // TEST\r\n      el.gridstackNode = el._gridstackNodeOrig;\r\n      delete el._gridstackNodeOrig;\r\n    } else if (node._isExternal) {\r\n      // item came from outside (like a toolbar) so nuke any node info\r\n      delete node.el;\r\n      delete el.gridstackNode;\r\n      // and restore all nodes back to original\r\n      this.engine.restoreInitial();\r\n    }\r\n  }\r\n\r\n  // legacy method removed\r\n  public commit(): GridStack { obsolete(this, this.batchUpdate(false), 'commit', 'batchUpdate', '5.2'); return this; }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}